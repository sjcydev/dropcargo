import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  children,
  claim_svg_element,
  detach_dev,
  dispatch_dev,
  empty,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  svg_element,
  toggle_class,
  validate_slots
} from "./chunk-PBX6AF7V.js";

// node_modules/svelte-fa/src/utils.js
var parseNumber = parseFloat;
function joinCss(obj, separator = ";") {
  let texts;
  if (Array.isArray(obj)) {
    texts = obj.filter((text) => text);
  } else {
    texts = [];
    for (const prop in obj) {
      if (obj[prop]) {
        texts.push(`${prop}:${obj[prop]}`);
      }
    }
  }
  return texts.join(separator);
}
function getStyles(style, size, pull, fw) {
  let float;
  let width;
  const height = "1em";
  let lineHeight;
  let fontSize;
  let textAlign;
  let verticalAlign = "-.125em";
  const overflow = "visible";
  if (fw) {
    textAlign = "center";
    width = "1.25em";
  }
  if (pull) {
    float = pull;
  }
  if (size) {
    if (size == "lg") {
      fontSize = "1.33333em";
      lineHeight = ".75em";
      verticalAlign = "-.225em";
    } else if (size == "xs") {
      fontSize = ".75em";
    } else if (size == "sm") {
      fontSize = ".875em";
    } else {
      fontSize = size.replace("x", "em");
    }
  }
  return joinCss([
    joinCss({
      float,
      width,
      height,
      "line-height": lineHeight,
      "font-size": fontSize,
      "text-align": textAlign,
      "vertical-align": verticalAlign,
      "transform-origin": "center",
      overflow
    }),
    style
  ]);
}
function getTransform(scale, translateX, translateY, rotate, flip, translateTimes = 1, translateUnit = "", rotateUnit = "") {
  let flipX = 1;
  let flipY = 1;
  if (flip) {
    if (flip == "horizontal") {
      flipX = -1;
    } else if (flip == "vertical") {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }
  return joinCss(
    [
      `translate(${parseNumber(translateX) * translateTimes}${translateUnit},${parseNumber(translateY) * translateTimes}${translateUnit})`,
      `scale(${flipX * parseNumber(scale)},${flipY * parseNumber(scale)})`,
      rotate && `rotate(${rotate}${rotateUnit})`
    ],
    " "
  );
}

// node_modules/svelte-fa/src/fa.svelte
var file = "node_modules/svelte-fa/src/fa.svelte";
function add_css(target) {
  append_styles(target, "svelte-1cj2gr0", ".spin.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 2s 0s infinite linear}.pulse.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 1s infinite steps(8)}@keyframes svelte-1cj2gr0-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStDQSxvQkFBTSxDQUNKLFNBQVMsQ0FBRSxtQkFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQ2pDLENBRUEscUJBQU8sQ0FDTCxTQUFTLENBQUUsbUJBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUNyQyxDQUVBLFdBQVcsbUJBQUssQ0FDZCxFQUFHLENBQ0QsU0FBUyxDQUFFLE9BQU8sSUFBSSxDQUN4QixDQUNBLElBQUssQ0FDSCxTQUFTLENBQUUsT0FBTyxNQUFNLENBQzFCLENBQ0YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiZmEuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let svg;
  let g1;
  let g0;
  let g1_transform_value;
  let g1_transform_origin_value;
  let svg_id_value;
  let svg_class_value;
  let svg_viewBox_value;
  function select_block_type(ctx2, dirty) {
    if (typeof /*i*/
    ctx2[10][4] == "string")
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        id: true,
        class: true,
        style: true,
        viewBox: true,
        "aria-hidden": true,
        role: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      g1 = claim_svg_element(svg_nodes, "g", {
        transform: true,
        "transform-origin": true
      });
      var g1_nodes = children(g1);
      g0 = claim_svg_element(g1_nodes, "g", { transform: true });
      var g0_nodes = children(g0);
      if_block.l(g0_nodes);
      g0_nodes.forEach(detach_dev);
      g1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        g0,
        "transform",
        /*transform*/
        ctx[12]
      );
      add_location(g0, file, 81, 6, 1397);
      attr_dev(g1, "transform", g1_transform_value = "translate(" + /*i*/
      ctx[10][0] / 2 + " " + /*i*/
      ctx[10][1] / 2 + ")");
      attr_dev(g1, "transform-origin", g1_transform_origin_value = /*i*/
      ctx[10][0] / 4 + " 0");
      add_location(g1, file, 77, 4, 1293);
      attr_dev(svg, "id", svg_id_value = /*id*/
      ctx[1] || void 0);
      attr_dev(svg, "class", svg_class_value = "svelte-fa " + /*clazz*/
      ctx[0] + " svelte-1cj2gr0");
      attr_dev(
        svg,
        "style",
        /*s*/
        ctx[11]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + /*i*/
      ctx[10][0] + " " + /*i*/
      ctx[10][1]);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "img");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      toggle_class(
        svg,
        "pulse",
        /*pulse*/
        ctx[4]
      );
      toggle_class(
        svg,
        "spin",
        /*spin*/
        ctx[3]
      );
      add_location(svg, file, 66, 2, 1071);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g1);
      append_hydration_dev(g1, g0);
      if_block.m(g0, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(g0, null);
        }
      }
      if (dirty & /*transform*/
      4096) {
        attr_dev(
          g0,
          "transform",
          /*transform*/
          ctx2[12]
        );
      }
      if (dirty & /*i*/
      1024 && g1_transform_value !== (g1_transform_value = "translate(" + /*i*/
      ctx2[10][0] / 2 + " " + /*i*/
      ctx2[10][1] / 2 + ")")) {
        attr_dev(g1, "transform", g1_transform_value);
      }
      if (dirty & /*i*/
      1024 && g1_transform_origin_value !== (g1_transform_origin_value = /*i*/
      ctx2[10][0] / 4 + " 0")) {
        attr_dev(g1, "transform-origin", g1_transform_origin_value);
      }
      if (dirty & /*id*/
      2 && svg_id_value !== (svg_id_value = /*id*/
      ctx2[1] || void 0)) {
        attr_dev(svg, "id", svg_id_value);
      }
      if (dirty & /*clazz*/
      1 && svg_class_value !== (svg_class_value = "svelte-fa " + /*clazz*/
      ctx2[0] + " svelte-1cj2gr0")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*s*/
      2048) {
        attr_dev(
          svg,
          "style",
          /*s*/
          ctx2[11]
        );
      }
      if (dirty & /*i*/
      1024 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*i*/
      ctx2[10][0] + " " + /*i*/
      ctx2[10][1])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (dirty & /*clazz, pulse*/
      17) {
        toggle_class(
          svg,
          "pulse",
          /*pulse*/
          ctx2[4]
        );
      }
      if (dirty & /*clazz, spin*/
      9) {
        toggle_class(
          svg,
          "spin",
          /*spin*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(66:0) {#if i[4]}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let path0;
  let path0_d_value;
  let path0_fill_value;
  let path0_fill_opacity_value;
  let path0_transform_value;
  let path1;
  let path1_d_value;
  let path1_fill_value;
  let path1_fill_opacity_value;
  let path1_transform_value;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        transform: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        transform: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", path0_d_value = /*i*/
      ctx[10][4][0]);
      attr_dev(path0, "fill", path0_fill_value = /*secondaryColor*/
      ctx[6] || /*color*/
      ctx[2] || "currentColor");
      attr_dev(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/
      ctx[9] != false ? (
        /*primaryOpacity*/
        ctx[7]
      ) : (
        /*secondaryOpacity*/
        ctx[8]
      ));
      attr_dev(path0, "transform", path0_transform_value = "translate(" + /*i*/
      ctx[10][0] / -2 + " " + /*i*/
      ctx[10][1] / -2 + ")");
      add_location(path0, file, 90, 10, 1678);
      attr_dev(path1, "d", path1_d_value = /*i*/
      ctx[10][4][1]);
      attr_dev(path1, "fill", path1_fill_value = /*primaryColor*/
      ctx[5] || /*color*/
      ctx[2] || "currentColor");
      attr_dev(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/
      ctx[9] != false ? (
        /*secondaryOpacity*/
        ctx[8]
      ) : (
        /*primaryOpacity*/
        ctx[7]
      ));
      attr_dev(path1, "transform", path1_transform_value = "translate(" + /*i*/
      ctx[10][0] / -2 + " " + /*i*/
      ctx[10][1] / -2 + ")");
      add_location(path1, file, 96, 10, 1935);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      1024 && path0_d_value !== (path0_d_value = /*i*/
      ctx2[10][4][0])) {
        attr_dev(path0, "d", path0_d_value);
      }
      if (dirty & /*secondaryColor, color*/
      68 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/
      ctx2[6] || /*color*/
      ctx2[2] || "currentColor")) {
        attr_dev(path0, "fill", path0_fill_value);
      }
      if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/
      896 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/
      ctx2[9] != false ? (
        /*primaryOpacity*/
        ctx2[7]
      ) : (
        /*secondaryOpacity*/
        ctx2[8]
      ))) {
        attr_dev(path0, "fill-opacity", path0_fill_opacity_value);
      }
      if (dirty & /*i*/
      1024 && path0_transform_value !== (path0_transform_value = "translate(" + /*i*/
      ctx2[10][0] / -2 + " " + /*i*/
      ctx2[10][1] / -2 + ")")) {
        attr_dev(path0, "transform", path0_transform_value);
      }
      if (dirty & /*i*/
      1024 && path1_d_value !== (path1_d_value = /*i*/
      ctx2[10][4][1])) {
        attr_dev(path1, "d", path1_d_value);
      }
      if (dirty & /*primaryColor, color*/
      36 && path1_fill_value !== (path1_fill_value = /*primaryColor*/
      ctx2[5] || /*color*/
      ctx2[2] || "currentColor")) {
        attr_dev(path1, "fill", path1_fill_value);
      }
      if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/
      896 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/
      ctx2[9] != false ? (
        /*secondaryOpacity*/
        ctx2[8]
      ) : (
        /*primaryOpacity*/
        ctx2[7]
      ))) {
        attr_dev(path1, "fill-opacity", path1_fill_opacity_value);
      }
      if (dirty & /*i*/
      1024 && path1_transform_value !== (path1_transform_value = "translate(" + /*i*/
      ctx2[10][0] / -2 + " " + /*i*/
      ctx2[10][1] / -2 + ")")) {
        attr_dev(path1, "transform", path1_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path0);
      if (detaching)
        detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(89:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let path;
  let path_d_value;
  let path_fill_value;
  let path_transform_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true, fill: true, transform: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", path_d_value = /*i*/
      ctx[10][4]);
      attr_dev(path, "fill", path_fill_value = /*color*/
      ctx[2] || /*primaryColor*/
      ctx[5] || "currentColor");
      attr_dev(path, "transform", path_transform_value = "translate(" + /*i*/
      ctx[10][0] / -2 + " " + /*i*/
      ctx[10][1] / -2 + ")");
      add_location(path, file, 83, 10, 1461);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      1024 && path_d_value !== (path_d_value = /*i*/
      ctx2[10][4])) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*color, primaryColor*/
      36 && path_fill_value !== (path_fill_value = /*color*/
      ctx2[2] || /*primaryColor*/
      ctx2[5] || "currentColor")) {
        attr_dev(path, "fill", path_fill_value);
      }
      if (dirty & /*i*/
      1024 && path_transform_value !== (path_transform_value = "translate(" + /*i*/
      ctx2[10][0] / -2 + " " + /*i*/
      ctx2[10][1] / -2 + ")")) {
        attr_dev(path, "transform", path_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(83:8) {#if typeof i[4] == 'string'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[10][4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*i*/
        ctx2[10][4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa", slots, []);
  let { class: clazz = "" } = $$props;
  let { id = "" } = $$props;
  let { style = "" } = $$props;
  let { icon } = $$props;
  let { size = "" } = $$props;
  let { color = "" } = $$props;
  let { fw = false } = $$props;
  let { pull = "" } = $$props;
  let { scale = 1 } = $$props;
  let { translateX = 0 } = $$props;
  let { translateY = 0 } = $$props;
  let { rotate = "" } = $$props;
  let { flip = false } = $$props;
  let { spin = false } = $$props;
  let { pulse = false } = $$props;
  let { primaryColor = "" } = $$props;
  let { secondaryColor = "" } = $$props;
  let { primaryOpacity = 1 } = $$props;
  let { secondaryOpacity = 0.4 } = $$props;
  let { swapOpacity = false } = $$props;
  let i;
  let s;
  let transform;
  $$self.$$.on_mount.push(function() {
    if (icon === void 0 && !("icon" in $$props || $$self.$$.bound[$$self.$$.props["icon"]])) {
      console.warn("<Fa> was created without expected prop 'icon'");
    }
  });
  const writable_props = [
    "class",
    "id",
    "style",
    "icon",
    "size",
    "color",
    "fw",
    "pull",
    "scale",
    "translateX",
    "translateY",
    "rotate",
    "flip",
    "spin",
    "pulse",
    "primaryColor",
    "secondaryColor",
    "primaryOpacity",
    "secondaryOpacity",
    "swapOpacity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fa> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("icon" in $$props2)
      $$invalidate(14, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(15, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("fw" in $$props2)
      $$invalidate(16, fw = $$props2.fw);
    if ("pull" in $$props2)
      $$invalidate(17, pull = $$props2.pull);
    if ("scale" in $$props2)
      $$invalidate(18, scale = $$props2.scale);
    if ("translateX" in $$props2)
      $$invalidate(19, translateX = $$props2.translateX);
    if ("translateY" in $$props2)
      $$invalidate(20, translateY = $$props2.translateY);
    if ("rotate" in $$props2)
      $$invalidate(21, rotate = $$props2.rotate);
    if ("flip" in $$props2)
      $$invalidate(22, flip = $$props2.flip);
    if ("spin" in $$props2)
      $$invalidate(3, spin = $$props2.spin);
    if ("pulse" in $$props2)
      $$invalidate(4, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2)
      $$invalidate(5, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2)
      $$invalidate(6, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2)
      $$invalidate(7, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2)
      $$invalidate(8, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2)
      $$invalidate(9, swapOpacity = $$props2.swapOpacity);
  };
  $$self.$capture_state = () => ({
    getStyles,
    getTransform,
    clazz,
    id,
    style,
    icon,
    size,
    color,
    fw,
    pull,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    i,
    s,
    transform
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2)
      $$invalidate(0, clazz = $$props2.clazz);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("icon" in $$props2)
      $$invalidate(14, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(15, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("fw" in $$props2)
      $$invalidate(16, fw = $$props2.fw);
    if ("pull" in $$props2)
      $$invalidate(17, pull = $$props2.pull);
    if ("scale" in $$props2)
      $$invalidate(18, scale = $$props2.scale);
    if ("translateX" in $$props2)
      $$invalidate(19, translateX = $$props2.translateX);
    if ("translateY" in $$props2)
      $$invalidate(20, translateY = $$props2.translateY);
    if ("rotate" in $$props2)
      $$invalidate(21, rotate = $$props2.rotate);
    if ("flip" in $$props2)
      $$invalidate(22, flip = $$props2.flip);
    if ("spin" in $$props2)
      $$invalidate(3, spin = $$props2.spin);
    if ("pulse" in $$props2)
      $$invalidate(4, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2)
      $$invalidate(5, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2)
      $$invalidate(6, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2)
      $$invalidate(7, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2)
      $$invalidate(8, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2)
      $$invalidate(9, swapOpacity = $$props2.swapOpacity);
    if ("i" in $$props2)
      $$invalidate(10, i = $$props2.i);
    if ("s" in $$props2)
      $$invalidate(11, s = $$props2.s);
    if ("transform" in $$props2)
      $$invalidate(12, transform = $$props2.transform);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*icon*/
    16384) {
      $:
        $$invalidate(10, i = icon && icon.icon || [0, 0, "", [], ""]);
    }
    if ($$self.$$.dirty & /*style, size, pull, fw*/
    237568) {
      $:
        $$invalidate(11, s = getStyles(style, size, pull, fw));
    }
    if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/
    8126464) {
      $:
        $$invalidate(12, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
    }
  };
  return [
    clazz,
    id,
    color,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    i,
    s,
    transform,
    style,
    icon,
    size,
    fw,
    pull,
    scale,
    translateX,
    translateY,
    rotate,
    flip
  ];
}
var Fa = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        class: 0,
        id: 1,
        style: 13,
        icon: 14,
        size: 15,
        color: 2,
        fw: 16,
        pull: 17,
        scale: 18,
        translateX: 19,
        translateY: 20,
        rotate: 21,
        flip: 22,
        spin: 3,
        pulse: 4,
        primaryColor: 5,
        secondaryColor: 6,
        primaryOpacity: 7,
        secondaryOpacity: 8,
        swapOpacity: 9
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fw() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fw(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateX() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateX(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateY() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateY(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_default = Fa;
export {
  fa_default as default
};
//# sourceMappingURL=svelte-fa.js.map
