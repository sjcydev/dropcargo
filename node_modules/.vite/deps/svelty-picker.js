import "./chunk-6A2TAOKG.js";
import {
  fade
} from "./chunk-NBPPRJZF.js";
import {
  cubicOut
} from "./chunk-M6MB33T7.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  null_to_empty,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  validate_each_argument,
  validate_each_keys,
  validate_slots
} from "./chunk-PBX6AF7V.js";

// node_modules/svelty-picker/i18n/index.js
var en = {
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
  daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  meridiem: ["am", "pm"],
  suffix: ["st", "nd", "rd", "th"],
  todayBtn: "Today",
  clearBtn: "Clear",
  timeView: "Show time view",
  backToDate: "Back to calendar view"
};

// node_modules/svelty-picker/utils/settings.js
var settings_default = {
  theme: "sdt-calendar-colors",
  mode: "auto",
  format: "yyyy-mm-dd",
  formatType: "standard",
  minuteIncrement: 1,
  weekStart: 1,
  inputClasses: "",
  todayBtnClasses: "sdt-action-btn sdt-today-btn",
  clearBtnClasses: "sdt-action-btn sdt-clear-btn",
  todayBtn: true,
  clearBtn: true,
  autoclose: true,
  clearToggle: true,
  i18n: en
};

// node_modules/svelty-picker/utils/dateUtils.js
var MODE_DECADE = 0;
var MODE_YEAR = 1;
var MODE_MONTH = 2;
function compute(currentDate, selectedDate, view, locale, weekStart) {
  if (view === MODE_DECADE) {
    let prevTo2 = 10;
    let nextFrom2 = 20;
    const todayMark2 = -1;
    const grid2 = [];
    let yearRow = [];
    let currYear = currentDate.getFullYear() - currentDate.getFullYear() % 10;
    currYear -= currYear % 20 ? 12 : 10;
    if (currYear % 10) {
      prevTo2 = 12;
      nextFrom2 = 22;
    }
    for (let i = 0; i < 32; i++) {
      yearRow.push(currYear + i);
      if (yearRow.length === 4) {
        grid2.push(yearRow);
        yearRow = [];
      }
    }
    let selectionMark2 = null;
    if (!selectedDate) {
      selectedDate = /* @__PURE__ */ new Date();
    }
    if (selectedDate.getFullYear() >= currYear) {
      selectionMark2 = selectedDate.getFullYear() % currYear;
    }
    return {
      years: grid2,
      todayMark: todayMark2,
      nextFrom: nextFrom2,
      prevTo: prevTo2,
      selectionMark: selectionMark2
    };
  }
  if (view === MODE_YEAR) {
    let grid2 = [];
    let monthRow = [];
    let prevTo2 = 12;
    let nextFrom2 = 24;
    const ISO = currentDate.toISOString().split("T")[0].substring(0, 8);
    const dateNormalized = /* @__PURE__ */ new Date(ISO + "01 00:00:00");
    const initYear = dateNormalized.getFullYear() - 1;
    dateNormalized.setFullYear(initYear);
    let todayMark2 = 0;
    for (let y2 = 0; y2 < 3; y2++) {
      for (let i = 0; i < 12; i++) {
        dateNormalized.setMonth(i);
        monthRow.push(locale.monthsShort[i % 12]);
        if (monthRow.length === 4) {
          grid2.push(monthRow);
          monthRow = [];
        }
      }
      dateNormalized.setFullYear(dateNormalized.getFullYear() + 1);
    }
    let selectionMark2 = null;
    if (!selectedDate) {
      selectedDate = /* @__PURE__ */ new Date();
    }
    if (selectedDate.getFullYear() - initYear >= 0 && selectedDate.getFullYear() - initYear <= 2) {
      selectionMark2 = selectedDate.getMonth() + (selectedDate.getFullYear() - initYear || 0) * 12;
    }
    return {
      months: grid2,
      todayMark: todayMark2,
      nextFrom: nextFrom2,
      prevTo: prevTo2,
      selectionMark: selectionMark2
    };
  }
  let d = currentDate || /* @__PURE__ */ new Date(), y = d.getFullYear(), m = d.getMonth(), dM = d.getDate(), h = d.getHours(), today = /* @__PURE__ */ new Date();
  let prevMonth = new Date(y, m - 1, 28, 0, 0, 0, 0), day = utils.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
  prevMonth.setDate(day);
  prevMonth.setDate(day - (prevMonth.getDay() - weekStart + 7) % 7);
  let nextMonth = new Date(prevMonth);
  nextMonth.setDate(nextMonth.getDate() + 42);
  let nextMonthValue = nextMonth.valueOf();
  let grid = [];
  let dayRow = [];
  let todayMark = -1;
  let selectionMark = null;
  let prevTo = 0;
  let nextFrom = 42;
  let inc = 0;
  while (prevMonth.valueOf() < nextMonthValue) {
    inc++;
    dayRow.push(new Date(prevMonth));
    if (prevMonth.getFullYear() < y || prevMonth.getFullYear() === y && prevMonth.getMonth() < m) {
      prevTo = inc;
    } else if (nextFrom === 42 && (prevMonth.getFullYear() > y || prevMonth.getFullYear() === y && prevMonth.getMonth() > m)) {
      nextFrom = inc - 1;
    }
    prevMonth.setDate(prevMonth.getDate() + 1);
    if (prevMonth.getFullYear() === today.getFullYear() && prevMonth.getMonth() === today.getMonth() && prevMonth.getDate() === today.getDate()) {
      todayMark = inc;
    }
    if (!selectionMark && selectedDate && prevMonth.getFullYear() === selectedDate.getFullYear() && prevMonth.getMonth() === selectedDate.getMonth() && prevMonth.getDate() === selectedDate.getDate()) {
      selectionMark = inc;
    }
    if (dayRow.length === 7) {
      grid.push(dayRow);
      dayRow = [];
    }
  }
  return {
    grid,
    todayMark,
    prevTo,
    nextFrom,
    selectionMark
  };
}
function moveGrid(newPos, view) {
  if (newPos < 0) {
    newPos = 42 + newPos;
  }
  return {
    x: newPos % 7,
    y: Math.floor(newPos / 7)
  };
}
var utils = {
  isLeapYear: function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  },
  getDaysInMonth: function(year, month) {
    return [31, utils.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
  }
};
function isLower(a, b) {
  if (!(a instanceof Date))
    return false;
  return a.getFullYear() < b.getFullYear() || (a.getMonth() < b.getMonth() || a.getDate() <= b.getDate());
}
function isGreater(a, b) {
  if (!(a instanceof Date))
    return false;
  return a.getFullYear() > b.getFullYear() || (a.getMonth() > b.getMonth() || a.getDate() >= b.getDate());
}
function parseDate(date, format, i18n, type) {
  if (date instanceof Date) {
    return date;
  }
  const commonFormats = type === "php" ? { date: "Y-m-d", datetime: "Y-m-d H:i", datetime_s: "Y-m-d H:i:s" } : { date: "yyyy-mm-dd", datetime: "yyyy-mm-dd hh:ii", datetime_s: "yyyy-mm-dd hh:ii:ss" };
  let parsedFormat;
  if (/^\d{4}\-\d{1,2}\-\d{1,2}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.date, type);
  } else if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.datetime, type);
  } else if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(date)) {
    parsedFormat = formatHelper.parseFormat(commonFormats.datetime_s, type);
  } else {
    parsedFormat = formatHelper.parseFormat(format, type);
  }
  const parts = date && date.toString().match(formatHelper.nonpunctuation) || [];
  date = /* @__PURE__ */ new Date();
  date.setHours(0, 0, 0, 0);
  const parsed = {};
  const { setters_order, setters_map } = formatHelper.setters(type);
  let val, part;
  if (parts.length !== parsedFormat.parts.length && parsedFormat.parts.includes("S")) {
    const splitSuffix = parts[parsedFormat.parts.indexOf("S") - 1].match(/(\d+)([a-zA-Z]+)/).slice(1, 3);
    parts.splice(parsedFormat.parts.indexOf("S") - 1, 1, ...splitSuffix);
  }
  if (parts.length === parsedFormat.parts.length) {
    for (var i = 0, cnt = parsedFormat.parts.length; i < cnt; i++) {
      val = parseInt(parts[i], 10);
      part = parsedFormat.parts[i];
      if (isNaN(val)) {
        if (type === "standard") {
          switch (part) {
            case "MM":
              val = i18n.months.indexOf(parts[i]) + 1;
              break;
            case "M":
              val = i18n.monthsShort.indexOf(parts[i]) + 1;
              break;
            case "p":
            case "P":
              val = i18n.meridiem.indexOf(parts[i].toLowerCase());
              break;
          }
        } else {
          switch (part) {
            case "D":
              val = i18n.daysShort.indexOf(parts[i]) + 1;
              break;
            case "l":
              val = i18n.days.indexOf(parts[i]) + 1;
              break;
            case "F":
              val = i18n.months.indexOf(parts[i]) + 1;
              break;
            case "M":
              val = i18n.monthsShort.indexOf(parts[i]) + 1;
              break;
            case "a":
            case "A":
              val = i18n.meridiem.indexOf(parts[i].toLowerCase());
              break;
          }
        }
      }
      parsed[part] = val;
    }
    for (var i = 0, s; i < setters_order.length; i++) {
      s = setters_order[i];
      if (s in parsed && !isNaN(parsed[s]))
        setters_map[`${s}`] && setters_map[`${s}`](date, parsed[s]);
    }
  }
  return date;
}
function formatDate(date, format, i18n, type) {
  if (date === null) {
    return "";
  }
  const dateVal = date.getDate();
  let val;
  if (type === "standard") {
    val = {
      t: date.getTime(),
      // year
      yy: date.getFullYear().toString().substring(2),
      yyyy: date.getFullYear(),
      // month
      m: date.getMonth() + 1,
      M: i18n.monthsShort[date.getMonth()],
      MM: i18n.months[date.getMonth()],
      // day
      d: dateVal,
      D: i18n.daysShort[date.getDay()],
      DD: i18n.days[date.getDay()],
      S: dateVal % 10 && dateVal % 10 <= i18n.suffix.length ? i18n.suffix[dateVal % 10 - 1] : i18n.suffix[i18n.suffix.length - 1],
      p: i18n.meridiem.length === 2 ? i18n.meridiem[date.getHours() < 12 ? 0 : 1] : "",
      // hour
      h: date.getHours(),
      // minute
      ii: (date.getMinutes() < 10 ? "0" : "") + date.getMinutes(),
      // second
      ss: (date.getUTCSeconds() < 10 ? "0" : "") + date.getUTCSeconds()
    };
    if (i18n.meridiem.length === 2) {
      val.H = val.h % 12 === 0 ? 12 : val.h % 12;
    } else {
      val.H = val.h;
    }
    val.HH = (val.H < 10 ? "0" : "") + val.H;
    val.P = val.p.toUpperCase();
    val.hh = (val.h < 10 ? "0" : "") + val.h;
    val.i = val.ii;
    val.s = val.ss;
    val.dd = (val.d < 10 ? "0" : "") + val.d;
    val.mm = (val.m < 10 ? "0" : "") + val.m;
  } else if (type === "php") {
    val = {
      // year
      y: date.getFullYear().toString().substring(2),
      Y: date.getFullYear(),
      // month
      F: i18n.months[date.getMonth()],
      M: i18n.monthsShort[date.getMonth()],
      n: date.getMonth() + 1,
      t: utils.getDaysInMonth(date.getFullYear(), date.getMonth()),
      // day
      j: date.getDate(),
      l: i18n.days[date.getDay()],
      D: i18n.daysShort[date.getDay()],
      w: date.getDay(),
      // 0 -> 6
      N: date.getDay() === 0 ? 7 : date.getDay(),
      // 1 -> 7
      S: dateVal % 10 && dateVal % 10 <= i18n.suffix.length ? i18n.suffix[dateVal % 10 - 1] : i18n.suffix[i18n.suffix.length - 1],
      // hour
      a: i18n.meridiem.length === 2 ? i18n.meridiem[date.getHours() < 12 ? 0 : 1] : "",
      g: date.getHours() % 12 === 0 ? 12 : date.getHours() % 12,
      G: date.getHours(),
      // minute
      i: date.getMinutes(),
      // second
      s: date.getSeconds(),
      U: Math.floor(date.getTime() / 1e3)
    };
    val.m = (val.n < 10 ? "0" : "") + val.n;
    val.d = (val.j < 10 ? "0" : "") + val.j;
    val.A = val.a.toString().toUpperCase();
    val.h = (val.g < 10 ? "0" : "") + val.g;
    val.H = (val.G < 10 ? "0" : "") + val.G;
    val.i = (val.i < 10 ? "0" : "") + val.i;
    val.s = (val.s < 10 ? "0" : "") + val.s;
  } else {
    throw new Error("Invalid format type.");
  }
  let dateArr = [];
  format = formatHelper.parseFormat(format, type);
  for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
    if (format.separators.length) {
      dateArr.push(format.separators.shift());
    }
    dateArr.push(val[format.parts[i]]);
  }
  if (format.separators.length) {
    dateArr.push(format.separators.shift());
  }
  return dateArr.join("");
}
var formatHelper = {
  validParts: function(type) {
    if (type === "standard") {
      return /t|hh?|HH?|p|P|z|ii?|ss?|dd?|DD?|S|mm?|MM?|yy(?:yy)?/g;
    } else if (type === "php") {
      return /[dDjlNwzFmMnStyYaABgGhHisU]/g;
    } else {
      throw new Error("Invalid format type.");
    }
  },
  nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g,
  /**
   * 
   * @param {string} format 
   * @param {string} type 
   * @returns {{ separators: string[], parts: string[]} }
   */
  parseFormat: function(format, type) {
    var separators = format.replace(this.validParts(type), "\0").split("\0"), parts = format.match(this.validParts(type));
    if (!separators || !separators.length || !parts || parts.length === 0) {
      console.warn("invalid date format", separators, parts);
      parts = [];
    }
    return { separators, parts };
  },
  /**
   * @param {string} type 
   * @returns {{setters_map: object, setters_order: Array<string>}}
   */
  setters: function(type) {
    let setters_order, setters_map;
    if (type === "standard") {
      setters_order = ["yyyy", "yy", "m", "mm", "M", "MM", "d", "dd", "D", "DD", "hh", "h", "HH", "H", "ii", "i", "ss", "s", "S", "p", "P", "t"];
      setters_map = {
        /** @param {Date} d, @param {number} v */
        hh: (d, v) => d.setHours(v),
        /** @param {Date} d, @param {number} v */
        h: (d, v) => d.setHours(v),
        /** @param {Date} d, @param {number} v */
        HH: (d, v) => d.setHours(v === 12 ? 0 : v),
        /** @param {Date} d, @param {number} v */
        H: (d, v) => d.setHours(v === 12 ? 0 : v),
        /** @param {Date} d, @param {number} v */
        i: (d, v) => d.setMinutes(v),
        /** @param {Date} d, @param {number} v */
        s: (d, v) => d.setSeconds(v),
        /** @param {Date} d, @param {number} v */
        yyyy: (d, v) => d.setFullYear(v),
        /** @param {Date} d, @param {number} v */
        yy: (d, v) => d.setFullYear((v < 50 ? 2e3 : 1900) + v),
        /** @param {Date} d, @param {number} v */
        m: (d, v) => {
          v -= 1;
          while (v < 0)
            v += 12;
          v %= 12;
          d.setMonth(v);
          while (d.getMonth() !== v)
            if (isNaN(d.getMonth()))
              return d;
            else
              d.setDate(d.getDate() - 1);
          return d;
        },
        /** @param {Date} d, @param {number} v */
        d: (d, v) => d.setDate(v),
        /** @param {Date} d, @param {number} v */
        p: (d, v) => d.setHours(v === 1 && d.getHours() < 12 ? d.getHours() + 12 : d.getHours()),
        /** @param {Date} d, @param {number} v */
        t: (d, v) => d.setTime(v),
        mm: () => {
        },
        M: () => {
        },
        MM: () => {
        },
        ii: () => {
        },
        ss: () => {
        },
        dd: () => {
        },
        D: () => {
        },
        DD: () => {
        },
        P: () => {
        }
      };
      setters_map.mm = setters_map.M = setters_map.MM = setters_map.m;
      setters_map.ii = setters_map.i;
      setters_map.ss = setters_map.s;
      setters_map.dd = setters_map.D = setters_map.DD = setters_map.d;
      setters_map.P = setters_map.p;
    } else {
      setters_order = ["Y", "yy", "m", "M", "F", "n", "d", "D", "j", "l", "N", "S", "H", "G", "h", "g", "i", "s", "p", "P", "U"];
      setters_map = {
        H: (d, v) => d.setHours(v),
        G: (d, v) => d.setHours(v),
        h: (d, v) => d.setHours(v === 12 ? 0 : v),
        g: (d, v) => d.setHours(v === 12 ? 0 : v),
        i: (d, v) => d.setMinutes(v),
        s: (d, v) => d.setSeconds(v),
        Y: (d, v) => d.setFullYear(v),
        yy: (d, v) => d.setFullYear((v < 50 ? 2e3 : 1900) + v),
        m: (d, v) => {
          v -= 1;
          while (v < 0)
            v += 12;
          v %= 12;
          d.setMonth(v);
          while (d.getMonth() !== v)
            if (isNaN(d.getMonth()))
              return d;
            else
              d.setDate(d.getDate() - 1);
          return d;
        },
        d: (d, v) => d.setDate(v),
        a: (d, v) => d.setHours(v === 1 ? d.getHours() + 12 : d.getHours()),
        U: (d, v) => d.setTime(v * 1e3)
      };
      setters_map.F = setters_map.M = setters_map.m;
      setters_map.D = setters_map.j = setters_map.l = setters_map.N = setters_map.d;
      setters_map.A = setters_map.a;
    }
    return { setters_order, setters_map };
  }
};

// node_modules/svelty-picker/utils/utils.js
function usePosition(el, { inputEl, visible, inputRect }) {
  if (!visible) {
    const calRect = el.getBoundingClientRect();
    const style = ["position: absolute", "z-index: 12250"];
    style.push(
      inputRect.x + calRect.width > window.innerWidth ? `right: 1rem` : `left: ${inputRect.left}px`
    );
    if (calRect.height + calRect.top > window.innerHeight + window.scrollY) {
      style.push(`bottom: 1rem`);
    } else {
      style.push(`top: ${inputRect.top + inputRect.height + window.scrollY}px`);
    }
    el.style = style.join(";");
    el.hidden = false;
    document.body.appendChild(el);
  }
  el.hidden = false;
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  return {
    destroy
  };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, end = 1, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const sd = 1 - start;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (_t, u) => `
        transform: ${transform} scale(${end !== 1 ? start + end * u : 1 - sd * u});
        opacity: ${target_opacity - od * u};
      `
  };
}

// node_modules/svelty-picker/components/Calendar.svelte
var file = "node_modules/svelty-picker/components/Calendar.svelte";
function add_css(target) {
  append_styles(target, "svelte-6hyah7", ".sdt-cal-td.svelte-6hyah7.svelte-6hyah7{padding:0;font-size:90%;text-align:center;background-color:var(--sdt-bg-main)}.sdt-cal-th.svelte-6hyah7.svelte-6hyah7{height:24px}.sdt-calendar.svelte-6hyah7.svelte-6hyah7{height:221px;overflow:hidden}.sdt-calendar.is-grid.svelte-6hyah7.svelte-6hyah7{display:grid}.sdt-calendar.is-grid.svelte-6hyah7 .sdt-table.svelte-6hyah7{grid-column:1/2;grid-row:1/2}.sdt-table.svelte-6hyah7.svelte-6hyah7{width:100%;border-collapse:collapse}.sdt-table-height.svelte-6hyah7.svelte-6hyah7{height:222px}.animate-transition.svelte-6hyah7.svelte-6hyah7{will-change:transform;transition:transform .3s ease}.not-current.svelte-6hyah7.svelte-6hyah7{opacity:0.3}.not-current.svelte-6hyah7.svelte-6hyah7:hover{opacity:0.55}.std-btn.svelte-6hyah7.svelte-6hyah7{margin:0;border:0;background:transparent;text-align:center;width:100%;border-radius:4px;cursor:pointer;padding:0.3rem;box-sizing:border-box;color:var(--sdt-color)}.sdt-btn-day.svelte-6hyah7.svelte-6hyah7{max-height:32px}.std-btn[disabled].svelte-6hyah7.svelte-6hyah7{cursor:not-allowed;opacity:0.5;color:var(--sdt-disabled-date, #b22222)}.std-btn-header.svelte-6hyah7.svelte-6hyah7{width:auto;font-weight:bold;padding:0.375rem 0.5rem}.std-btn-header.icon-btn.svelte-6hyah7.svelte-6hyah7:first-of-type{padding-left:0.375rem;padding-right:0.375rem}.std-btn-header.icon-btn.svelte-6hyah7.svelte-6hyah7{padding-left:0.25rem;padding-right:0.25rem}.std-btn.svelte-6hyah7.svelte-6hyah7:hover{background-color:var(--sdt-btn-bg-hover)}.is-selected.svelte-6hyah7 .std-btn.svelte-6hyah7{background-color:var(--sdt-primary);color:var(--sdt-color-selected, var(--sdt-bg-main));opacity:0.9}.std-btn-header.svelte-6hyah7.svelte-6hyah7:hover{background-color:var(--sdt-btn-header-bg-hover)}.sdt-time-icon.svelte-6hyah7.svelte-6hyah7{margin-right:-4px}.sdt-time-icon.svelte-6hyah7 svg.svelte-6hyah7{margin:4px 0}.sdt-tbody-lg.svelte-6hyah7.svelte-6hyah7{background-color:var(--sdt-bg-main)}.sdt-tbody-lg.svelte-6hyah7 .std-btn.svelte-6hyah7{height:74px}.sdt-thead-nav.svelte-6hyah7.svelte-6hyah7{display:flex;margin-bottom:0.25rem}.sdt-nav-btns.svelte-6hyah7.svelte-6hyah7{white-space:nowrap}.sdt-toggle-btn.svelte-6hyah7.svelte-6hyah7{width:100%;text-align:left}.sdt-today.svelte-6hyah7.svelte-6hyah7:before{box-sizing:border-box;position:absolute;content:'';margin-left:4px;margin-top:4px;border-left:4px solid var(--sdt-shadow);border-top:4px solid var(--sdt-shadow);border-bottom:4px solid transparent;border-right:4px solid transparent;border-radius:2px;height:4px;z-index:2}.sdt-svg.svelte-6hyah7.svelte-6hyah7{fill:var(--sdt-color)}.sdt-today.svelte-6hyah7.svelte-6hyah7:hover:before{border-left-color:var(--sdt-primary);border-top-color:var(--sdt-primary)}.is-selected.sdt-today.svelte-6hyah7.svelte-6hyah7:before{border-left-color:#eee;border-top-color:#eee}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNZQSx1Q0FBWSxDQUNWLE9BQU8sQ0FBRSxDQUFDLENBQ1YsU0FBUyxDQUFFLEdBQUcsQ0FDZCxVQUFVLENBQUUsTUFBTSxDQUNsQixnQkFBZ0IsQ0FBRSxJQUFJLGFBQWEsQ0FDckMsQ0FDQSx1Q0FBWSxDQUNWLE1BQU0sQ0FBRSxJQUNWLENBQ0EseUNBQWMsQ0FDWixNQUFNLENBQUUsS0FBSyxDQUNiLFFBQVEsQ0FBRSxNQUNaLENBQ0EsYUFBYSxvQ0FBUyxDQUNwQixPQUFPLENBQUUsSUFDWCxDQUNBLGFBQWEsc0JBQVEsQ0FBQyx3QkFBVyxDQUMvQixXQUFXLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDaEIsUUFBUSxDQUFFLENBQUMsQ0FBQyxDQUNkLENBQ0Esc0NBQVcsQ0FDVCxLQUFLLENBQUUsSUFBSSxDQUNYLGVBQWUsQ0FBRSxRQUNuQixDQUNBLDZDQUFrQixDQUNoQixNQUFNLENBQUUsS0FDVixDQUNBLCtDQUFvQixDQUNsQixXQUFXLENBQUUsU0FBUyxDQUN0QixVQUFVLENBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUM1QixDQUNBLHdDQUFhLENBQ1gsT0FBTyxDQUFFLEdBQ1gsQ0FDQSx3Q0FBWSxNQUFPLENBQ2pCLE9BQU8sQ0FBRSxJQUNYLENBQ0Esb0NBQVMsQ0FDUCxNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxDQUFDLENBQ1QsVUFBVSxDQUFFLFdBQVcsQ0FDdkIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxhQUFhLENBQUUsR0FBRyxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxNQUFNLENBQ2YsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsS0FBSyxDQUFFLElBQUksV0FBVyxDQUN4QixDQUNBLHdDQUFhLENBQ1gsVUFBVSxDQUFFLElBQ2QsQ0FDQSxRQUFRLENBQUMsUUFBUSw2QkFBRSxDQUNqQixNQUFNLENBQUUsV0FBVyxDQUNuQixPQUFPLENBQUUsR0FBRyxDQUNaLEtBQUssQ0FBRSxJQUFJLG1CQUFtQixDQUFDLFFBQVEsQ0FDekMsQ0FDQSwyQ0FBZ0IsQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE9BQU8sQ0FBRSxRQUFRLENBQUMsTUFDcEIsQ0FDQSxlQUFlLHFDQUFTLGNBQWUsQ0FDckMsWUFBWSxDQUFFLFFBQVEsQ0FDdEIsYUFBYSxDQUFFLFFBQ2pCLENBQ0EsZUFBZSxxQ0FBVSxDQUN2QixZQUFZLENBQUUsT0FBTyxDQUNyQixhQUFhLENBQUUsT0FDakIsQ0FDQSxvQ0FBUSxNQUFPLENBQ2IsZ0JBQWdCLENBQUUsSUFBSSxrQkFBa0IsQ0FDMUMsQ0FDQSwwQkFBWSxDQUFDLHNCQUFTLENBQ3BCLGdCQUFnQixDQUFFLElBQUksYUFBYSxDQUFDLENBQ3BDLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLENBQ3BELE9BQU8sQ0FBRSxHQUNYLENBQ0EsMkNBQWUsTUFBTyxDQUNwQixnQkFBZ0IsQ0FBRSxJQUFJLHlCQUF5QixDQUNqRCxDQUNBLDBDQUFlLENBQ2IsWUFBWSxDQUFFLElBQ2hCLENBQ0EsNEJBQWMsQ0FBQyxpQkFBSSxDQUNqQixNQUFNLENBQUUsR0FBRyxDQUFDLENBQ2QsQ0FDQSx5Q0FBYyxDQUNaLGdCQUFnQixDQUFFLElBQUksYUFBYSxDQUNyQyxDQUNBLDJCQUFhLENBQUMsc0JBQVMsQ0FDckIsTUFBTSxDQUFFLElBQ1YsQ0FDQSwwQ0FBZSxDQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsYUFBYSxDQUFFLE9BQ2pCLENBQ0EseUNBQWMsQ0FDWixXQUFXLENBQUUsTUFDZixDQUNBLDJDQUFnQixDQUNkLEtBQUssQ0FBRSxJQUFJLENBQ1gsVUFBVSxDQUFFLElBQ2QsQ0FDQSxzQ0FBVSxPQUFRLENBQ2hCLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxFQUFFLENBQ1gsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsVUFBVSxDQUFFLEdBQUcsQ0FDZixXQUFXLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUN4QyxVQUFVLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUN2QyxhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQ3BDLFlBQVksQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDbkMsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsTUFBTSxDQUFFLEdBQUcsQ0FDWCxPQUFPLENBQUUsQ0FDWCxDQUNBLG9DQUFTLENBQ1AsSUFBSSxDQUFFLElBQUksV0FBVyxDQUN2QixDQUNBLHNDQUFVLE1BQU0sT0FBUSxDQUN0QixpQkFBaUIsQ0FBRSxJQUFJLGFBQWEsQ0FBQyxDQUNyQyxnQkFBZ0IsQ0FBRSxJQUFJLGFBQWEsQ0FDckMsQ0FDQSxZQUFZLHNDQUFVLE9BQVEsQ0FDNUIsaUJBQWlCLENBQUUsSUFBSSxDQUN2QixnQkFBZ0IsQ0FBRSxJQUNwQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYWxlbmRhci5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  child_ctx[46] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[51] = list[i];
  child_ctx[46] = i;
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[54] = list[i];
  child_ctx[46] = i;
  return child_ctx;
}
function create_if_block_3(ctx) {
  let button;
  let svg;
  let path;
  let button_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, title: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { "fill-rule": true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0zM8 0a8 8 0 100 16A8 8 0 008 0zm.5 4.75a.75.75 0 00-1.5 0v3.5a.75.75 0 00.471.696l2.5 1a.75.75 0 00.557-1.392L8.5 7.742V4.75z");
      add_location(path, file, 301, 105, 10952);
      attr_dev(svg, "class", "sdt-svg svelte-6hyah7");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 16 16");
      attr_dev(svg, "width", "16");
      attr_dev(svg, "height", "16");
      add_location(svg, file, 301, 6, 10853);
      attr_dev(button, "class", "std-btn std-btn-header icon-btn sdt-time-icon svelte-6hyah7");
      attr_dev(button, "title", button_title_value = /*i18n*/
      ctx[0].timeView);
      add_location(button, file, 300, 4, 10721);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(
          /*onTimeSwitch*/
          ctx[22]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n*/
      1 && button_title_value !== (button_title_value = /*i18n*/
      ctx2[0].timeView)) {
        attr_dev(button, "title", button_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(300:4) {#if enableTimeToggle && internalDate}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let table;
  let tbody;
  let tbody_style_value;
  let tbody_intro;
  let tbody_outro;
  let current;
  let mounted;
  let dispose;
  let each_value_5 = (
    /*dataset*/
    ctx[10].years
  );
  validate_each_argument(each_value_5);
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true, style: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", { class: true, style: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tbody, "class", "sdt-tbody-lg svelte-6hyah7");
      attr_dev(tbody, "style", tbody_style_value = `transform: translateY(-${/*transform*/
      ctx[7]}px); color: red`);
      toggle_class(
        tbody,
        "animate-transition",
        /*onMonthTransitionTrigger*/
        ctx[8] ? true : false
      );
      add_location(tbody, file, 315, 4, 12098);
      attr_dev(table, "class", "sdt-table svelte-6hyah7");
      set_style(table, "max-height", "221px");
      set_style(table, "height", "221px");
      add_location(table, file, 314, 2, 12026);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            tbody,
            "outroend",
            /*onTransitionOut*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tbody,
            "transitionend",
            /*transitionend_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dataset, isDisabledDate, activeDate, isBetween, onClick*/
      1246216) {
        each_value_5 = /*dataset*/
        ctx[10].years;
        validate_each_argument(each_value_5);
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_5.length;
      }
      if (!current || dirty[0] & /*transform*/
      128 && tbody_style_value !== (tbody_style_value = `transform: translateY(-${/*transform*/
      ctx[7]}px); color: red`)) {
        attr_dev(tbody, "style", tbody_style_value);
      }
      if (!current || dirty[0] & /*onMonthTransitionTrigger*/
      256) {
        toggle_class(
          tbody,
          "animate-transition",
          /*onMonthTransitionTrigger*/
          ctx[8] ? true : false
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (tbody_outro)
          tbody_outro.end(1);
        tbody_intro = create_in_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            start: (
              /*start*/
              ctx[14]
            ),
            opacity: 1
          }
        );
        tbody_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (tbody_intro)
        tbody_intro.invalidate();
      if (local) {
        tbody_outro = create_out_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            end: (
              /*end*/
              ctx[13]
            ),
            start: 1
          }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks, detaching);
      if (detaching && tbody_outro)
        tbody_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(314:2) {#if currentView === MODE_DECADE}",
    ctx
  });
  return block;
}
function create_each_block_6(key_1, ctx) {
  let td;
  let button;
  let t_value = (
    /*year*/
    ctx[54] + ""
  );
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[31](
        /*year*/
        ctx[54]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      td = element("td");
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      button = claim_element(td_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "std-btn svelte-6hyah7");
      button.disabled = button_disabled_value = /*isDisabledDate*/
      ctx[17](new Date(
        /*year*/
        ctx[54],
        /*activeDate*/
        ctx[3].getMonth(),
        /*activeDate*/
        ctx[3].getDate()
      ));
      toggle_class(button, "not-current", !/*isBetween*/
      ctx[16](
        /*i*/
        ctx[43] * 4 + /*j*/
        ctx[46]
      ));
      add_location(button, file, 324, 10, 12713);
      attr_dev(td, "class", "sdt-cal-td svelte-6hyah7");
      toggle_class(
        td,
        "is-selected",
        /*i*/
        ctx[43] * 4 + /*j*/
        ctx[46] === /*dataset*/
        ctx[10].selectionMark
      );
      add_location(td, file, 323, 8, 12626);
      this.first = td;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(click_handler_2), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dataset*/
      1024 && t_value !== (t_value = /*year*/
      ctx[54] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*dataset, activeDate*/
      1032 && button_disabled_value !== (button_disabled_value = /*isDisabledDate*/
      ctx[17](new Date(
        /*year*/
        ctx[54],
        /*activeDate*/
        ctx[3].getMonth(),
        /*activeDate*/
        ctx[3].getDate()
      )))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (dirty[0] & /*isBetween, dataset*/
      66560) {
        toggle_class(button, "not-current", !/*isBetween*/
        ctx[16](
          /*i*/
          ctx[43] * 4 + /*j*/
          ctx[46]
        ));
      }
      if (dirty[0] & /*dataset*/
      1024) {
        toggle_class(
          td,
          "is-selected",
          /*i*/
          ctx[43] * 4 + /*j*/
          ctx[46] === /*dataset*/
          ctx[10].selectionMark
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_6.name,
    type: "each",
    source: "(323:8) {#each row as year, j(j)}",
    ctx
  });
  return block;
}
function create_each_block_5(ctx) {
  let tr;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_6 = (
    /*row*/
    ctx[41]
  );
  validate_each_argument(each_value_6);
  const get_key = (ctx2) => (
    /*j*/
    ctx2[46]
  );
  validate_each_keys(ctx, each_value_6, get_each_context_6, get_key);
  for (let i = 0; i < each_value_6.length; i += 1) {
    let child_ctx = get_each_context_6(ctx, each_value_6, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_6(key, child_ctx));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "sdt-cal-td svelte-6hyah7");
      add_location(tr, file, 321, 6, 12558);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*dataset, isDisabledDate, activeDate, isBetween, onClick*/
      1246216) {
        each_value_6 = /*row*/
        ctx2[41];
        validate_each_argument(each_value_6);
        validate_each_keys(ctx2, each_value_6, get_each_context_6, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_6, each_1_lookup, tr, destroy_block, create_each_block_6, t, get_each_context_6);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(321:6) {#each dataset.years as row, i}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let table;
  let tbody;
  let tbody_style_value;
  let tbody_intro;
  let tbody_outro;
  let current;
  let mounted;
  let dispose;
  let each_value_3 = (
    /*dataset*/
    ctx[10].months
  );
  validate_each_argument(each_value_3);
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", { class: true, style: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tbody, "class", "sdt-tbody-lg svelte-6hyah7");
      attr_dev(tbody, "style", tbody_style_value = `transform: translateY(-${/*transform*/
      ctx[7]}px)`);
      toggle_class(
        tbody,
        "animate-transition",
        /*onMonthTransitionTrigger*/
        ctx[8] ? true : false
      );
      add_location(tbody, file, 339, 4, 13157);
      attr_dev(table, "class", "sdt-table svelte-6hyah7");
      add_location(table, file, 338, 2, 13126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            tbody,
            "outroend",
            /*onTransitionOut*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tbody,
            "transitionend",
            /*transitionend_handler_1*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dataset, isDisabledDate, activeDate, i18n, isBetween, onClick*/
      1246217) {
        each_value_3 = /*dataset*/
        ctx[10].months;
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (!current || dirty[0] & /*transform*/
      128 && tbody_style_value !== (tbody_style_value = `transform: translateY(-${/*transform*/
      ctx[7]}px)`)) {
        attr_dev(tbody, "style", tbody_style_value);
      }
      if (!current || dirty[0] & /*onMonthTransitionTrigger*/
      256) {
        toggle_class(
          tbody,
          "animate-transition",
          /*onMonthTransitionTrigger*/
          ctx[8] ? true : false
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (tbody_outro)
          tbody_outro.end(1);
        tbody_intro = create_in_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            start: (
              /*start*/
              ctx[14]
            ),
            opacity: 1
          }
        );
        tbody_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (tbody_intro)
        tbody_intro.invalidate();
      if (local) {
        tbody_outro = create_out_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            end: (
              /*end*/
              ctx[13]
            ),
            start: 1
          }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks, detaching);
      if (detaching && tbody_outro)
        tbody_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(338:2) {#if currentView === MODE_YEAR}",
    ctx
  });
  return block;
}
function create_each_block_4(key_1, ctx) {
  let td;
  let button;
  let t_value = (
    /*month*/
    ctx[51] + ""
  );
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[33](
        /*month*/
        ctx[51]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      td = element("td");
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      button = claim_element(td_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "std-btn svelte-6hyah7");
      button.disabled = button_disabled_value = /*isDisabledDate*/
      ctx[17](new Date(
        /*activeDate*/
        ctx[3].getFullYear(),
        /*i18n*/
        ctx[0].monthsShort.indexOf(
          /*month*/
          ctx[51]
        ),
        /*activeDate*/
        ctx[3].getDate()
      ));
      toggle_class(button, "not-current", !/*isBetween*/
      ctx[16](
        /*i*/
        ctx[43] * 4 + /*j*/
        ctx[46]
      ));
      add_location(button, file, 347, 10, 13739);
      attr_dev(td, "class", "sdt-cal-td svelte-6hyah7");
      toggle_class(
        td,
        "is-selected",
        /*i*/
        ctx[43] * 4 + /*j*/
        ctx[46] === /*dataset*/
        ctx[10].selectionMark
      );
      add_location(td, file, 346, 8, 13652);
      this.first = td;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(click_handler_3), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dataset*/
      1024 && t_value !== (t_value = /*month*/
      ctx[51] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*activeDate, i18n, dataset*/
      1033 && button_disabled_value !== (button_disabled_value = /*isDisabledDate*/
      ctx[17](new Date(
        /*activeDate*/
        ctx[3].getFullYear(),
        /*i18n*/
        ctx[0].monthsShort.indexOf(
          /*month*/
          ctx[51]
        ),
        /*activeDate*/
        ctx[3].getDate()
      )))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (dirty[0] & /*isBetween, dataset*/
      66560) {
        toggle_class(button, "not-current", !/*isBetween*/
        ctx[16](
          /*i*/
          ctx[43] * 4 + /*j*/
          ctx[46]
        ));
      }
      if (dirty[0] & /*dataset*/
      1024) {
        toggle_class(
          td,
          "is-selected",
          /*i*/
          ctx[43] * 4 + /*j*/
          ctx[46] === /*dataset*/
          ctx[10].selectionMark
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(346:8) {#each row as month, j(j)}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let tr;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_4 = (
    /*row*/
    ctx[41]
  );
  validate_each_argument(each_value_4);
  const get_key = (ctx2) => (
    /*j*/
    ctx2[46]
  );
  validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);
  for (let i = 0; i < each_value_4.length; i += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_4(key, child_ctx));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "sdt-cal-td svelte-6hyah7");
      add_location(tr, file, 344, 6, 13583);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*dataset, isDisabledDate, activeDate, i18n, isBetween, onClick*/
      1246217) {
        each_value_4 = /*row*/
        ctx2[41];
        validate_each_argument(each_value_4);
        validate_each_keys(ctx2, each_value_4, get_each_context_4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, tr, destroy_block, create_each_block_4, t, get_each_context_4);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(344:6) {#each dataset.months as row, i}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let table;
  let tbody;
  let tr;
  let t;
  let tbody_intro;
  let tbody_outro;
  let current;
  let mounted;
  let dispose;
  let each_value_2 = (
    /*dayLabels*/
    ctx[11]
  );
  validate_each_argument(each_value_2);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = (
    /*dataset*/
    ctx[10].grid
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      tr = claim_element(tbody_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      t = claim_space(tbody_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "sdt-cal-td svelte-6hyah7");
      add_location(tr, file, 362, 6, 14384);
      add_location(tbody, file, 361, 4, 14218);
      attr_dev(table, "class", "sdt-table sdt-table-height svelte-6hyah7");
      add_location(table, file, 360, 2, 14170);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      append_hydration_dev(tbody, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append_hydration_dev(tbody, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          tbody,
          "outroend",
          /*onTransitionOut*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dayLabels*/
      2048) {
        each_value_2 = /*dayLabels*/
        ctx[11];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & /*dataset, isDisabledDate, isBetween, onClick*/
      1246208) {
        each_value = /*dataset*/
        ctx[10].grid;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (tbody_outro)
          tbody_outro.end(1);
        tbody_intro = create_in_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            start: 0.5,
            opacity: 1
          }
        );
        tbody_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (tbody_intro)
        tbody_intro.invalidate();
      if (local) {
        tbody_outro = create_out_transition(
          tbody,
          /*swapTransition*/
          ctx[12],
          {
            duration: (
              /*duration*/
              ctx[15]
            ),
            start: Math.abs(
              /*viewDelta*/
              ctx[5]
            )
          }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (detaching && tbody_outro)
        tbody_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(360:2) {#if currentView === MODE_MONTH}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let th;
  let t_value = (
    /*header*/
    ctx[47] + ""
  );
  let t;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "sdt-cal-th svelte-6hyah7");
      add_location(th, file, 364, 8, 14452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*dayLabels*/
      2048 && t_value !== (t_value = /*header*/
      ctx2[47] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(364:6) {#each dayLabels as header}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let td;
  let button;
  let t_value = (
    /*currDate*/
    ctx[44].getDate() + ""
  );
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[35](
        /*currDate*/
        ctx[44]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      td = element("td");
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      button = claim_element(td_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "std-btn sdt-btn-day svelte-6hyah7");
      button.disabled = button_disabled_value = /*isDisabledDate*/
      ctx[17](
        /*currDate*/
        ctx[44]
      );
      toggle_class(button, "not-current", !/*isBetween*/
      ctx[16](
        /*i*/
        ctx[43] * 7 + /*j*/
        ctx[46]
      ));
      add_location(button, file, 374, 10, 14781);
      attr_dev(td, "class", "sdt-cal-td svelte-6hyah7");
      toggle_class(
        td,
        "sdt-today",
        /*i*/
        ctx[43] * 7 + /*j*/
        ctx[46] === /*dataset*/
        ctx[10].todayMark
      );
      toggle_class(
        td,
        "is-selected",
        /*i*/
        ctx[43] * 7 + /*j*/
        ctx[46] === /*dataset*/
        ctx[10].selectionMark
      );
      add_location(td, file, 370, 8, 14616);
      this.first = td;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(click_handler_4), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*dataset*/
      1024 && t_value !== (t_value = /*currDate*/
      ctx[44].getDate() + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*dataset*/
      1024 && button_disabled_value !== (button_disabled_value = /*isDisabledDate*/
      ctx[17](
        /*currDate*/
        ctx[44]
      ))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (dirty[0] & /*isBetween, dataset*/
      66560) {
        toggle_class(button, "not-current", !/*isBetween*/
        ctx[16](
          /*i*/
          ctx[43] * 7 + /*j*/
          ctx[46]
        ));
      }
      if (dirty[0] & /*dataset*/
      1024) {
        toggle_class(
          td,
          "sdt-today",
          /*i*/
          ctx[43] * 7 + /*j*/
          ctx[46] === /*dataset*/
          ctx[10].todayMark
        );
      }
      if (dirty[0] & /*dataset*/
      1024) {
        toggle_class(
          td,
          "is-selected",
          /*i*/
          ctx[43] * 7 + /*j*/
          ctx[46] === /*dataset*/
          ctx[10].selectionMark
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(370:8) {#each row as currDate, j(j)}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let tr;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_1 = (
    /*row*/
    ctx[41]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => (
    /*j*/
    ctx2[46]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file, 368, 6, 14563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*dataset, isDisabledDate, isBetween, onClick*/
      1246208) {
        each_value_1 = /*row*/
        ctx2[41];
        validate_each_argument(each_value_1);
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, tr, destroy_block, create_each_block_1, t, get_each_context_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(368:6) {#each dataset.grid as row, i }",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let button0;
  let t0;
  let t1;
  let div0;
  let t2;
  let button1;
  let svg0;
  let path0;
  let t3;
  let button2;
  let svg1;
  let path1;
  let t4;
  let div2;
  let t5;
  let t6;
  let mounted;
  let dispose;
  let if_block0 = (
    /*enableTimeToggle*/
    ctx[1] && /*internalDate*/
    ctx[2] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*currentView*/
    ctx[4] === MODE_DECADE && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*currentView*/
    ctx[4] === MODE_YEAR && create_if_block_1(ctx)
  );
  let if_block3 = (
    /*currentView*/
    ctx[4] === MODE_MONTH && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      button0 = element("button");
      t0 = text(
        /*tableCaption*/
        ctx[9]
      );
      t1 = space();
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      button1 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t3 = space();
      button2 = element("button");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t4 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t5 = space();
      if (if_block2)
        if_block2.c();
      t6 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button0 = claim_element(div1_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(
        button0_nodes,
        /*tableCaption*/
        ctx[9]
      );
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      svg0 = claim_svg_element(button1_nodes, "svg", {
        class: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      button2 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button2_nodes = children(button2);
      svg1 = claim_svg_element(button2_nodes, "svg", {
        class: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      button2_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block1)
        if_block1.l(div2_nodes);
      t5 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      t6 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", "std-btn std-btn-header sdt-toggle-btn svelte-6hyah7");
      add_location(button0, file, 297, 2, 10525);
      attr_dev(path0, "d", "M4.427 9.573l3.396-3.396a.25.25 0 01.354 0l3.396 3.396a.25.25 0 01-.177.427H4.604a.25.25 0 01-.177-.427z");
      add_location(path0, file, 305, 105, 11408);
      attr_dev(svg0, "class", "sdt-svg svelte-6hyah7");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "viewBox", "0 0 16 16");
      attr_dev(svg0, "width", "24");
      attr_dev(svg0, "height", "24");
      add_location(svg0, file, 305, 6, 11309);
      attr_dev(button1, "class", "std-btn std-btn-header icon-btn svelte-6hyah7");
      add_location(button1, file, 304, 4, 11194);
      attr_dev(path1, "d", "M4.427 7.427l3.396 3.396a.25.25 0 00.354 0l3.396-3.396A.25.25 0 0011.396 7H4.604a.25.25 0 00-.177.427z");
      add_location(path1, file, 308, 105, 11770);
      attr_dev(svg1, "class", "sdt-svg svelte-6hyah7");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "viewBox", "0 0 16 16");
      attr_dev(svg1, "width", "24");
      attr_dev(svg1, "height", "24");
      add_location(svg1, file, 308, 6, 11671);
      attr_dev(button2, "class", "std-btn std-btn-header icon-btn svelte-6hyah7");
      add_location(button2, file, 307, 4, 11557);
      attr_dev(div0, "class", "sdt-nav-btns svelte-6hyah7");
      add_location(div0, file, 298, 2, 10645);
      attr_dev(div1, "class", "sdt-thead-nav svelte-6hyah7");
      add_location(div1, file, 296, 0, 10494);
      attr_dev(div2, "class", "sdt-calendar svelte-6hyah7");
      toggle_class(
        div2,
        "is-grid",
        /*viewChanged*/
        ctx[6]
      );
      add_location(div2, file, 312, 0, 11931);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, button1);
      append_hydration_dev(button1, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, button2);
      append_hydration_dev(button2, svg1);
      append_hydration_dev(svg1, path1);
      insert_hydration_dev(target, t4, anchor);
      insert_hydration_dev(target, div2, anchor);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t5);
      if (if_block2)
        if_block2.m(div2, null);
      append_hydration_dev(div2, t6);
      if (if_block3)
        if_block3.m(div2, null);
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", prevent_default(
            /*onSwitchView*/
            ctx[19]
          ), false, true, false, false),
          listen_dev(button1, "click", prevent_default(
            /*click_handler*/
            ctx[29]
          ), false, true, false, false),
          listen_dev(button2, "click", prevent_default(
            /*click_handler_1*/
            ctx[30]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*tableCaption*/
      512)
        set_data_dev(
          t0,
          /*tableCaption*/
          ctx2[9]
        );
      if (
        /*enableTimeToggle*/
        ctx2[1] && /*internalDate*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*currentView*/
        ctx2[4] === MODE_DECADE
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*currentView*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*currentView*/
        ctx2[4] === MODE_YEAR
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*currentView*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t6);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*currentView*/
        ctx2[4] === MODE_MONTH
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*currentView*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*viewChanged*/
      64) {
        toggle_class(
          div2,
          "is-grid",
          /*viewChanged*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach_dev(t4);
      if (detaching)
        detach_dev(div2);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var TRANSFORM_CONST = 222;
var TRANSFORM_DECADE_UNEVEN = 148;
function instance($$self, $$props, $$invalidate) {
  let computedStartDate;
  let start;
  let end;
  let swapTransition;
  let dataset;
  let dayLabels;
  let tableCaption;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { date = null } = $$props;
  let { startDate = null } = $$props;
  let { endDate = null } = $$props;
  let { weekStart = 1 } = $$props;
  let { initialView = MODE_MONTH } = $$props;
  let { i18n } = $$props;
  let { enableTimeToggle = false } = $$props;
  function handleGridNav(key, shiftKey) {
    if (!internalDate) {
      onClick(/* @__PURE__ */ new Date());
      return;
    }
    let pos, diffSelection;
    switch (key) {
      case "PageDown":
        shiftKey = true;
      case "ArrowDown":
        if (shiftKey)
          return handleShiftNav(activeDate.getFullYear(), activeDate.getMonth() + 1, 1);
        diffSelection = dataset.selectionMark + 7;
        if (diffSelection >= dataset.nextFrom) {
          const tmpDate = new Date(activeDate.getFullYear(), activeDate.getUTCMonth() + 1, 28);
          let tmpData = compute(tmpDate, internalDate, currentView, i18n, weekStart);
          onChangeMonth(1);
          pos = tmpData.selectionMark !== null ? {
            y: Math.floor((tmpData.selectionMark + 7) / 7),
            x: (tmpData.selectionMark + 7) % 7
          } : {
            y: (diffSelection + 7) % 7 < tmpData.prevTo ? 1 : 0,
            x: (diffSelection + 7) % 7
          };
          onClick(tmpData.grid[pos.y][pos.x]);
          return;
        }
        pos = moveGrid(dataset.selectionMark + 7, currentView);
        if (dataset.grid[pos.y][pos.x].getMonth() !== activeDate.getMonth()) {
          onChangeMonth(1);
        }
        onClick(dataset.grid[pos.y][pos.x]);
        break;
      case "PageUp":
        shiftKey = true;
      case "ArrowUp":
        if (shiftKey)
          return handleShiftNav(activeDate.getFullYear(), activeDate.getMonth() - 1, -1);
        diffSelection = dataset.selectionMark - 7;
        if (diffSelection <= dataset.prevTo) {
          const tmpDate = new Date(
            activeDate.getFullYear() + (activeDate.getMonth() > 0 ? 0 : -1),
            activeDate.getMonth() > 0 ? activeDate.getMonth() - 1 : 11,
            1
          );
          const tmpData = compute(tmpDate, internalDate, currentView, i18n, weekStart);
          onChangeMonth(-1);
          pos = tmpData.selectionMark !== null ? {
            x: Math.floor((tmpData.selectionMark - 7) / 7),
            y: (tmpData.selectionMark - 7) % 7
          } : { x: 5, y: diffSelection };
          onClick(tmpData.grid[pos.x][pos.y]);
          return;
        }
        pos = moveGrid(dataset.selectionMark - 7, currentView);
        if (dataset.grid[pos.y][pos.x].getMonth() !== activeDate.getMonth()) {
          onChangeMonth(-1);
        }
        onClick(dataset.grid[pos.y][pos.x]);
        break;
      case "ArrowLeft":
        if (shiftKey)
          return handleShiftNav(activeDate.getFullYear() - 1, activeDate.getMonth(), 1);
        pos = moveGrid(dataset.selectionMark - 1, currentView);
        if (dataset.grid[pos.y][pos.x].getMonth() !== activeDate.getMonth()) {
          onChangeMonth(-1);
        }
        onClick(dataset.grid[pos.y][pos.x]);
        break;
      case "ArrowRight":
        if (shiftKey)
          return handleShiftNav(activeDate.getFullYear() + 1, activeDate.getMonth(), 1);
        pos = moveGrid(dataset.selectionMark + 1, currentView);
        if (dataset.grid[pos.y][pos.x].getMonth() !== activeDate.getMonth()) {
          onChangeMonth(1);
        }
        onClick(dataset.grid[pos.y][pos.x]);
        break;
    }
  }
  function handleShiftNav(year, month, monthChange) {
    let tmpDate;
    let newDateDay = activeDate.getDate();
    do {
      tmpDate = new Date(year, month, newDateDay);
      newDateDay--;
    } while (tmpDate.getMonth() === activeDate.getMonth());
    const tmpData = compute(tmpDate, tmpDate, currentView, i18n, weekStart);
    const pickedDate = tmpData.grid[Math.floor(tmpData.selectionMark / 7)][tmpData.selectionMark % 7];
    if (endDate && isGreater(pickedDate, endDate) || startDate && isLower(pickedDate, startDate))
      return;
    onChangeMonth(monthChange);
    onClick(pickedDate);
  }
  let internalDate = date;
  let activeDate = date ? new Date(date.valueOf()) : /* @__PURE__ */ new Date();
  const dispatch = createEventDispatcher();
  let currentView = initialView;
  let viewDelta = -2;
  let viewChanged = false;
  let duration = 400;
  let transform = TRANSFORM_CONST;
  let onMonthTransitionTrigger = null;
  function isBetween(num) {
    return dataset.prevTo <= num && num < dataset.nextFrom;
  }
  function isDisabledDate(date2) {
    switch (currentView) {
      case MODE_MONTH:
        if (computedStartDate && computedStartDate > date2)
          return true;
        if (endDate && endDate <= date2)
          return true;
        break;
      case MODE_YEAR:
        if (computedStartDate && computedStartDate.getFullYear() === date2.getFullYear() && computedStartDate.getMonth() > date2.getMonth())
          return true;
        if (endDate && endDate.getFullYear() === date2.getFullYear() && endDate.getMonth() < date2.getMonth())
          return true;
        break;
      case MODE_DECADE:
        if (computedStartDate && computedStartDate.getFullYear() > date2.getFullYear())
          return true;
        if (endDate && endDate.getFullYear() < date2.getFullYear())
          return true;
        break;
    }
    return false;
  }
  function onChangeMonth(val) {
    const multiplier = currentView === MODE_DECADE ? 120 : currentView === MODE_YEAR ? 12 : 1;
    activeDate.setMonth(activeDate.getMonth() + val * multiplier);
    $$invalidate(3, activeDate), $$invalidate(23, date), $$invalidate(2, internalDate);
    $$invalidate(8, onMonthTransitionTrigger = null);
    $$invalidate(7, transform = currentView === MODE_DECADE ? activeDate.getFullYear() % 20 >= 10 ? TRANSFORM_CONST : TRANSFORM_DECADE_UNEVEN : TRANSFORM_CONST);
  }
  function onTransformChangeMonth(val) {
    if (currentView === MODE_MONTH) {
      return onChangeMonth(val);
    }
    $$invalidate(8, onMonthTransitionTrigger = () => {
      onChangeMonth(val);
    });
    if (currentView === MODE_DECADE) {
      $$invalidate(7, transform = transform === TRANSFORM_DECADE_UNEVEN ? val === -1 ? transform - TRANSFORM_CONST : TRANSFORM_CONST + TRANSFORM_DECADE_UNEVEN : val === -1 ? transform - TRANSFORM_CONST : transform + TRANSFORM_DECADE_UNEVEN);
      return;
    }
    $$invalidate(7, transform = val === -1 ? transform - TRANSFORM_CONST : transform + TRANSFORM_CONST);
  }
  function onSwitchView() {
    $$invalidate(5, viewDelta = -1);
    $$invalidate(6, viewChanged = true);
    currentView && $$invalidate(4, currentView--, currentView);
    if (currentView === MODE_DECADE) {
      const isLongerMove = Math.floor(activeDate.getFullYear() / 10) * 10 % 20 === 0;
      $$invalidate(7, transform = isLongerMove ? TRANSFORM_DECADE_UNEVEN : TRANSFORM_CONST);
    }
  }
  function onClick(value) {
    $$invalidate(5, viewDelta = 1);
    $$invalidate(6, viewChanged = true);
    switch (currentView) {
      case 0:
        activeDate.setFullYear(value);
        $$invalidate(3, activeDate), $$invalidate(23, date), $$invalidate(2, internalDate);
        break;
      case 1:
        activeDate.setMonth(i18n.monthsShort.indexOf(value));
        $$invalidate(3, activeDate), $$invalidate(23, date), $$invalidate(2, internalDate);
        break;
      case 2:
        if (startDate && !isGreater(value, startDate))
          return;
        if (endDate && !isLower(value, endDate))
          return;
        const newInternalDate = new Date(value.getFullYear(), value.getMonth(), value.getDate());
        if (internalDate) {
          newInternalDate.setMinutes(internalDate.getMinutes());
          newInternalDate.setHours(internalDate.getHours());
        }
        $$invalidate(2, internalDate = newInternalDate);
        dispatch("date", internalDate);
        break;
    }
    currentView < MODE_MONTH && $$invalidate(4, currentView++, currentView);
    $$invalidate(7, transform = TRANSFORM_CONST);
  }
  function onTransitionOut() {
    $$invalidate(6, viewChanged = false);
  }
  function onTimeSwitch() {
    dispatch("switch", "time");
  }
  function showCaption(currentView2, activeDate2) {
    switch (currentView2) {
      case MODE_DECADE:
        const from = [Math.floor(dataset.prevTo / 4), dataset.prevTo % 4];
        const to = [Math.floor(dataset.nextFrom / 4), dataset.nextFrom % 4];
        return `${dataset.years[from.shift()][from.shift()]} - ${dataset.years[to.shift()][to.shift()] - 1}`;
      case MODE_YEAR:
        return activeDate2.getFullYear();
      case MODE_MONTH:
        return i18n.months[activeDate2.getMonth()] + " " + activeDate2.getFullYear();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<Calendar> was created without expected prop 'i18n'");
    }
  });
  const writable_props = [
    "date",
    "startDate",
    "endDate",
    "weekStart",
    "initialView",
    "i18n",
    "enableTimeToggle"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  const click_handler = () => onTransformChangeMonth(-1);
  const click_handler_1 = () => onTransformChangeMonth(1);
  const click_handler_2 = (year) => {
    onClick(year);
  };
  const transitionend_handler = () => onMonthTransitionTrigger && onMonthTransitionTrigger();
  const click_handler_3 = (month) => {
    onClick(month);
  };
  const transitionend_handler_1 = () => onMonthTransitionTrigger && onMonthTransitionTrigger();
  const click_handler_4 = (currDate) => {
    onClick(currDate);
  };
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(23, date = $$props2.date);
    if ("startDate" in $$props2)
      $$invalidate(24, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(25, endDate = $$props2.endDate);
    if ("weekStart" in $$props2)
      $$invalidate(26, weekStart = $$props2.weekStart);
    if ("initialView" in $$props2)
      $$invalidate(27, initialView = $$props2.initialView);
    if ("i18n" in $$props2)
      $$invalidate(0, i18n = $$props2.i18n);
    if ("enableTimeToggle" in $$props2)
      $$invalidate(1, enableTimeToggle = $$props2.enableTimeToggle);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    fade,
    compute,
    MODE_MONTH,
    MODE_YEAR,
    MODE_DECADE,
    moveGrid,
    isLower,
    isGreater,
    scale,
    date,
    startDate,
    endDate,
    weekStart,
    initialView,
    i18n,
    enableTimeToggle,
    handleGridNav,
    handleShiftNav,
    internalDate,
    activeDate,
    dispatch,
    currentView,
    viewDelta,
    viewChanged,
    duration,
    TRANSFORM_CONST,
    TRANSFORM_DECADE_UNEVEN,
    transform,
    onMonthTransitionTrigger,
    isBetween,
    isDisabledDate,
    onChangeMonth,
    onTransformChangeMonth,
    onSwitchView,
    onClick,
    onTransitionOut,
    onTimeSwitch,
    showCaption,
    tableCaption,
    dataset,
    computedStartDate,
    dayLabels,
    swapTransition,
    end,
    start
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(23, date = $$props2.date);
    if ("startDate" in $$props2)
      $$invalidate(24, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(25, endDate = $$props2.endDate);
    if ("weekStart" in $$props2)
      $$invalidate(26, weekStart = $$props2.weekStart);
    if ("initialView" in $$props2)
      $$invalidate(27, initialView = $$props2.initialView);
    if ("i18n" in $$props2)
      $$invalidate(0, i18n = $$props2.i18n);
    if ("enableTimeToggle" in $$props2)
      $$invalidate(1, enableTimeToggle = $$props2.enableTimeToggle);
    if ("internalDate" in $$props2)
      $$invalidate(2, internalDate = $$props2.internalDate);
    if ("activeDate" in $$props2)
      $$invalidate(3, activeDate = $$props2.activeDate);
    if ("currentView" in $$props2)
      $$invalidate(4, currentView = $$props2.currentView);
    if ("viewDelta" in $$props2)
      $$invalidate(5, viewDelta = $$props2.viewDelta);
    if ("viewChanged" in $$props2)
      $$invalidate(6, viewChanged = $$props2.viewChanged);
    if ("duration" in $$props2)
      $$invalidate(15, duration = $$props2.duration);
    if ("transform" in $$props2)
      $$invalidate(7, transform = $$props2.transform);
    if ("onMonthTransitionTrigger" in $$props2)
      $$invalidate(8, onMonthTransitionTrigger = $$props2.onMonthTransitionTrigger);
    if ("tableCaption" in $$props2)
      $$invalidate(9, tableCaption = $$props2.tableCaption);
    if ("dataset" in $$props2)
      $$invalidate(10, dataset = $$props2.dataset);
    if ("computedStartDate" in $$props2)
      computedStartDate = $$props2.computedStartDate;
    if ("dayLabels" in $$props2)
      $$invalidate(11, dayLabels = $$props2.dayLabels);
    if ("swapTransition" in $$props2)
      $$invalidate(12, swapTransition = $$props2.swapTransition);
    if ("end" in $$props2)
      $$invalidate(13, end = $$props2.end);
    if ("start" in $$props2)
      $$invalidate(14, start = $$props2.start);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*startDate*/
    16777216) {
      $:
        computedStartDate = startDate ? new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0, 0) : null;
    }
    if ($$self.$$.dirty[0] & /*date, internalDate*/
    8388612) {
      $: {
        if (date !== internalDate) {
          $$invalidate(2, internalDate = date);
          if (date) {
            $$invalidate(3, activeDate = new Date(date.valueOf()));
          }
          ;
          $$invalidate(5, viewDelta = 1);
          $$invalidate(6, viewChanged = true);
          $$invalidate(4, currentView = MODE_MONTH);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*viewDelta*/
    32) {
      $:
        $$invalidate(14, start = viewDelta < 1 ? 1.5 : 0.5);
    }
    if ($$self.$$.dirty[0] & /*viewDelta*/
    32) {
      $:
        $$invalidate(13, end = viewDelta < 1 ? 1 : 1.5);
    }
    if ($$self.$$.dirty[0] & /*viewDelta*/
    32) {
      $:
        $$invalidate(12, swapTransition = viewDelta === -2 ? fade : viewDelta !== null ? scale : () => {
        });
    }
    if ($$self.$$.dirty[0] & /*activeDate, internalDate, currentView, i18n, weekStart*/
    67108893) {
      $:
        $$invalidate(10, dataset = compute(activeDate, internalDate, currentView, i18n, weekStart));
    }
    if ($$self.$$.dirty[0] & /*weekStart, i18n*/
    67108865) {
      $:
        $$invalidate(11, dayLabels = weekStart > -1 ? i18n.daysMin.concat(i18n.daysMin).slice(weekStart, 7 + weekStart) : i18n.daysMin.slice(weekStart, 7 + weekStart));
    }
    if ($$self.$$.dirty[0] & /*i18n, currentView, activeDate*/
    25) {
      $:
        $$invalidate(9, tableCaption = i18n && showCaption(currentView, activeDate));
    }
  };
  return [
    i18n,
    enableTimeToggle,
    internalDate,
    activeDate,
    currentView,
    viewDelta,
    viewChanged,
    transform,
    onMonthTransitionTrigger,
    tableCaption,
    dataset,
    dayLabels,
    swapTransition,
    end,
    start,
    duration,
    isBetween,
    isDisabledDate,
    onTransformChangeMonth,
    onSwitchView,
    onClick,
    onTransitionOut,
    onTimeSwitch,
    date,
    startDate,
    endDate,
    weekStart,
    initialView,
    handleGridNav,
    click_handler,
    click_handler_1,
    click_handler_2,
    transitionend_handler,
    click_handler_3,
    transitionend_handler_1,
    click_handler_4
  ];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        date: 23,
        startDate: 24,
        endDate: 25,
        weekStart: 26,
        initialView: 27,
        i18n: 0,
        enableTimeToggle: 1,
        handleGridNav: 28
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment.name
    });
  }
  get date() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startDate() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startDate(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endDate() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endDate(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weekStart() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weekStart(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialView() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialView(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableTimeToggle() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableTimeToggle(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleGridNav() {
    return this.$$.ctx[28];
  }
  set handleGridNav(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

// node_modules/svelty-picker/components/Time.svelte
var file2 = "node_modules/svelty-picker/components/Time.svelte";
function add_css2(target) {
  append_styles(target, "svelte-163fzlc", ".sdt-timer.svelte-163fzlc.svelte-163fzlc{position:relative;width:272px}.sdt-time-head.svelte-163fzlc.svelte-163fzlc{position:relative;display:flex;justify-content:center;align-items:center;margin-bottom:4px}.sdt-time-figure.svelte-163fzlc.svelte-163fzlc{font-size:1.5rem;font-weight:bold}.sdt-clock.svelte-163fzlc.svelte-163fzlc{margin:auto;position:relative;width:260px;height:260px;background-color:var(--sdt-clock-bg);border-radius:50%;transition:background-color 0.3s;overflow:hidden}.sdt-time-btn.svelte-163fzlc.svelte-163fzlc{border:0;background:transparent;text-align:center;border-radius:4px;cursor:pointer;padding:0 0.375rem;color:var(--sdt-color)}.sdt-svg.svelte-163fzlc.svelte-163fzlc{fill:var(--sdt-color)}.sdt-time-btn.svelte-163fzlc.svelte-163fzlc:not(.is-active){opacity:0.5}.sdt-time-btn.svelte-163fzlc.svelte-163fzlc:hover{background-color:var(--sdt-btn-header-bg-hover)}.sdt-back-btn.svelte-163fzlc.svelte-163fzlc{position:absolute;top:0;left:0;padding:0.375rem;opacity:1 !important}.sdt-meridian.svelte-163fzlc.svelte-163fzlc{position:absolute;top:0;right:40px;display:flex}.sdt-meridian.svelte-163fzlc .sdt-time-btn.svelte-163fzlc{width:56px;font-weight:bold}.sdt-middle-dot.svelte-163fzlc.svelte-163fzlc{left:50%;top:50%;width:6px;height:6px;position:absolute;transform:translate(-50%, -50%);background-color:var(--sdt-primary);border-radius:50%}.sdt-hand-pointer.svelte-163fzlc.svelte-163fzlc{width:2px;height:calc(40% + 1px);bottom:50%;left:calc(50% - 1px);position:absolute;background-color:var(--sdt-primary);transform-origin:center bottom 0;transition:transform 0.3s ease, height 0.15s ease}.sdt-hand-circle.svelte-163fzlc.svelte-163fzlc{left:-15px;top:-21px;position:relative;width:4px;height:4px;background-color:transparent;border:14px solid var(--sdt-primary);border-radius:50%;box-sizing:content-box}.sdt-tick.svelte-163fzlc.svelte-163fzlc{position:absolute;width:30px;height:30px;border-width:0;transform:translate(-50%, -50%);text-align:center;border-radius:50%;line-height:20px;cursor:pointer;background-color:transparent;transition:all 0.3s}.sdt-tick[disabled].svelte-163fzlc.svelte-163fzlc{cursor:not-allowed}.sdt-tick.outer-tick.svelte-163fzlc.svelte-163fzlc{opacity:0}.sdt-tick.is-selected.svelte-163fzlc.svelte-163fzlc{animation:svelte-163fzlc-tick-selection 0s 0.175s ease-out forwards}@keyframes svelte-163fzlc-tick-selection{0%{color:initial;background-color:transparent}100%{background-color:var(--sdt-primary);color:var(--sdt-color-selected, var(--sdt-bg-main))}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaVhBLHdDQUFXLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLEtBQ1QsQ0FDQSw0Q0FBZSxDQUNiLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsYUFBYSxDQUFFLEdBQ2pCLENBQ0EsOENBQWlCLENBQ2YsU0FBUyxDQUFFLE1BQU0sQ0FDakIsV0FBVyxDQUFFLElBQ2YsQ0FDQSx3Q0FBVyxDQUNULE1BQU0sQ0FBRSxJQUFJLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLEtBQUssQ0FDWixNQUFNLENBQUUsS0FBSyxDQUNiLGdCQUFnQixDQUFFLElBQUksY0FBYyxDQUFDLENBQ3JDLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FBQyxJQUFJLENBQ2pDLFFBQVEsQ0FBRSxNQUNaLENBQ0EsMkNBQWMsQ0FDWixNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxXQUFXLENBQ3ZCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsT0FBTyxDQUFFLENBQUMsQ0FBQyxRQUFRLENBQ25CLEtBQUssQ0FBRSxJQUFJLFdBQVcsQ0FDeEIsQ0FDQSxzQ0FBUyxDQUNQLElBQUksQ0FBRSxJQUFJLFdBQVcsQ0FDdkIsQ0FDQSwyQ0FBYSxLQUFLLFVBQVUsQ0FBRSxDQUM1QixPQUFPLENBQUUsR0FDWCxDQUNBLDJDQUFhLE1BQU8sQ0FDbEIsZ0JBQWdCLENBQUUsSUFBSSx5QkFBeUIsQ0FDakQsQ0FDQSwyQ0FBYyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxPQUFPLENBQUUsUUFBUSxDQUNqQixPQUFPLENBQUUsQ0FBQyxDQUFDLFVBQ2IsQ0FDQSwyQ0FBYyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsSUFDWCxDQUNBLDRCQUFhLENBQUMsNEJBQWMsQ0FDMUIsS0FBSyxDQUFFLElBQUksQ0FDWCxXQUFXLENBQUUsSUFDZixDQUNBLDZDQUFnQixDQUNkLElBQUksQ0FBRSxHQUFHLENBQ1QsR0FBRyxDQUFFLEdBQUcsQ0FDUixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2hDLGdCQUFnQixDQUFFLElBQUksYUFBYSxDQUFDLENBQ3BDLGFBQWEsQ0FBRSxHQUNqQixDQUNBLCtDQUFrQixDQUNoQixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3ZCLE1BQU0sQ0FBRSxHQUFHLENBQ1gsSUFBSSxDQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDckIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsZ0JBQWdCLENBQUUsSUFBSSxhQUFhLENBQUMsQ0FDcEMsZ0JBQWdCLENBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQ2pDLFVBQVUsQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFDaEQsQ0FDQSw4Q0FBaUIsQ0FDZixJQUFJLENBQUUsS0FBSyxDQUNYLEdBQUcsQ0FBRSxLQUFLLENBQ1YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUNYLGdCQUFnQixDQUFFLFdBQVcsQ0FDN0IsTUFBTSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FDckMsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsVUFBVSxDQUFFLFdBQ2QsQ0FDQSx1Q0FBVSxDQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixZQUFZLENBQUUsQ0FBQyxDQUNmLFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUNoQyxVQUFVLENBQUUsTUFBTSxDQUNsQixhQUFhLENBQUUsR0FBRyxDQUNsQixXQUFXLENBQUUsSUFBSSxDQUNqQixNQUFNLENBQUUsT0FBTyxDQUNmLGdCQUFnQixDQUFFLFdBQVcsQ0FDN0IsVUFBVSxDQUFFLEdBQUcsQ0FBQyxJQUNsQixDQUNBLFNBQVMsQ0FBQyxRQUFRLCtCQUFFLENBQ2xCLE1BQU0sQ0FBRSxXQUNWLENBQ0EsU0FBUyx5Q0FBWSxDQUNuQixPQUFPLENBQUUsQ0FDWCxDQUNBLFNBQVMsMENBQWEsQ0FDcEIsU0FBUyxDQUFFLDZCQUFjLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFDL0MsQ0FDQSxXQUFXLDZCQUFlLENBQ3hCLEVBQUcsQ0FDRCxLQUFLLENBQUUsT0FBTyxDQUNkLGdCQUFnQixDQUFFLFdBQ3BCLENBQ0EsSUFBSyxDQUNILGdCQUFnQixDQUFFLElBQUksYUFBYSxDQUFDLENBQ3BDLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLG1CQUFtQixDQUNyRCxDQUNGIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRpbWUuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[38] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[38] = i;
  return child_ctx;
}
function create_if_block_12(ctx) {
  let button;
  let svg;
  let path;
  let button_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, title: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { "fill-rule": true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M6.75 0a.75.75 0 01.75.75V3h9V.75a.75.75 0 011.5 0V3h2.75c.966 0 1.75.784 1.75 1.75v16a1.75 1.75 0 01-1.75 1.75H3.25a1.75 1.75 0 01-1.75-1.75v-16C1.5 3.784 2.284 3 3.25 3H6V.75A.75.75 0 016.75 0zm-3.5 4.5a.25.25 0 00-.25.25V8h18V4.75a.25.25 0 00-.25-.25H3.25zM21 9.5H3v11.25c0 .138.112.25.25.25h17.5a.25.25 0 00.25-.25V9.5z");
      add_location(path, file2, 326, 105, 9877);
      attr_dev(svg, "class", "sdt-svg svelte-163fzlc");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      add_location(svg, file2, 326, 6, 9778);
      attr_dev(button, "class", "sdt-time-btn sdt-back-btn svelte-163fzlc");
      attr_dev(button, "title", button_title_value = /*i18n*/
      ctx[4].backToDate);
      add_location(button, file2, 325, 4, 9680);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onModeSwitch*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n*/
      16 && button_title_value !== (button_title_value = /*i18n*/
      ctx2[4].backToDate)) {
        attr_dev(button, "title", button_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(325:4) {#if hasDateComponent}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let button;
  let t_value = (
    /*isPM*/
    ctx[11] ? "PM" : "AM"
  );
  let t;
  let button_data_value_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", {
        type: true,
        class: true,
        "data-value": true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "sdt-time-btn sdt-time-figure is-active svelte-163fzlc");
      attr_dev(button, "data-value", button_data_value_value = /*isPM*/
      ctx[11] ? (
        /*selectedHour*/
        ctx[6] % 12
      ) : (
        /*selectedHour*/
        ctx[6] + 12
      ));
      add_location(button, file2, 340, 6, 10717);
      attr_dev(div, "class", "sdt-meridian svelte-163fzlc");
      add_location(div, file2, 339, 4, 10683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onSwitchMeridian*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*isPM*/
      2048 && t_value !== (t_value = /*isPM*/
      ctx2[11] ? "PM" : "AM"))
        set_data_dev(t, t_value);
      if (dirty[0] & /*isPM, selectedHour*/
      2112 && button_data_value_value !== (button_data_value_value = /*isPM*/
      ctx2[11] ? (
        /*selectedHour*/
        ctx2[6] % 12
      ) : (
        /*selectedHour*/
        ctx2[6] + 12
      ))) {
        attr_dev(button, "data-value", button_data_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(339:4) {#if showMeridian}",
    ctx
  });
  return block;
}
function create_each_block_12(key_1, ctx) {
  let button;
  let t_value = (
    /*p*/
    ctx[36].val + ""
  );
  let t;
  let button_style_value;
  let button_data_value_value;
  let button_disabled_value;
  let button_transition;
  let current;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        style: true,
        class: true,
        "data-value": true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "style", button_style_value = `left:${/*p*/
      ctx[36].x}px; top:${/*p*/
      ctx[36].y}px`);
      attr_dev(button, "class", "sdt-tick svelte-163fzlc");
      attr_dev(button, "data-value", button_data_value_value = /*p*/
      ctx[36].val);
      button.disabled = button_disabled_value = /*startDate*/
      (ctx[0] || /*endDate*/
      ctx[1]) && /*isDisabled*/
      ctx[16](
        /*p*/
        ctx[36].val,
        false
      );
      toggle_class(
        button,
        "outer-tick",
        /*isMinuteView*/
        ctx[5]
      );
      toggle_class(
        button,
        "is-selected",
        /*isSelected*/
        ctx[15](
          /*selectedHour*/
          ctx[6],
          /*p*/
          ctx[36].val,
          /*i*/
          ctx[38]
        )
      );
      add_location(button, file2, 352, 6, 11319);
      this.first = button;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*pos*/
      8192) && t_value !== (t_value = /*p*/
      ctx[36].val + ""))
        set_data_dev(t, t_value);
      if (!current || dirty[0] & /*pos*/
      8192 && button_style_value !== (button_style_value = `left:${/*p*/
      ctx[36].x}px; top:${/*p*/
      ctx[36].y}px`)) {
        attr_dev(button, "style", button_style_value);
      }
      if (!current || dirty[0] & /*pos*/
      8192 && button_data_value_value !== (button_data_value_value = /*p*/
      ctx[36].val)) {
        attr_dev(button, "data-value", button_data_value_value);
      }
      if (!current || dirty[0] & /*startDate, endDate, pos*/
      8195 && button_disabled_value !== (button_disabled_value = /*startDate*/
      (ctx[0] || /*endDate*/
      ctx[1]) && /*isDisabled*/
      ctx[16](
        /*p*/
        ctx[36].val,
        false
      ))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (!current || dirty[0] & /*isMinuteView*/
      32) {
        toggle_class(
          button,
          "outer-tick",
          /*isMinuteView*/
          ctx[5]
        );
      }
      if (!current || dirty[0] & /*isSelected, selectedHour, pos*/
      41024) {
        toggle_class(
          button,
          "is-selected",
          /*isSelected*/
          ctx[15](
            /*selectedHour*/
            ctx[6],
            /*p*/
            ctx[36].val,
            /*i*/
            ctx[38]
          )
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!button_transition)
            button_transition = create_bidirectional_transition(button, fade, { duration: 200 }, true);
          button_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!button_transition)
          button_transition = create_bidirectional_transition(button, fade, { duration: 200 }, false);
        button_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (detaching && button_transition)
        button_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(352:4) {#each pos as p, i(p.val)}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let button;
  let t_value = (
    /*p*/
    ctx[36].val + ""
  );
  let t;
  let button_style_value;
  let button_data_value_value;
  let button_disabled_value;
  let button_transition;
  let current;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        style: true,
        class: true,
        "data-value": true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "style", button_style_value = `left:${/*p*/
      ctx[36].x}px; top:${/*p*/
      ctx[36].y}px;`);
      attr_dev(button, "class", "sdt-tick svelte-163fzlc");
      attr_dev(button, "data-value", button_data_value_value = /*p*/
      ctx[36].val);
      button.disabled = button_disabled_value = /*startDate*/
      (ctx[0] || /*endDate*/
      ctx[1]) && /*isDisabled*/
      ctx[16](
        /*p*/
        ctx[36].val,
        false
      );
      toggle_class(
        button,
        "outer-tick",
        /*showMeridian*/
        ctx[2] && !/*isMinuteView*/
        ctx[5]
      );
      toggle_class(
        button,
        "is-selected",
        /*isSelected*/
        ctx[15](
          /*isMinuteView*/
          ctx[5] ? (
            /*selectedMinutes*/
            ctx[7]
          ) : (
            /*selectedHour*/
            ctx[6]
          ),
          /*p*/
          ctx[36].val,
          /*i*/
          ctx[38]
        )
      );
      add_location(button, file2, 359, 6, 11710);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*innerHours*/
      4096) && t_value !== (t_value = /*p*/
      ctx2[36].val + ""))
        set_data_dev(t, t_value);
      if (!current || dirty[0] & /*innerHours*/
      4096 && button_style_value !== (button_style_value = `left:${/*p*/
      ctx2[36].x}px; top:${/*p*/
      ctx2[36].y}px;`)) {
        attr_dev(button, "style", button_style_value);
      }
      if (!current || dirty[0] & /*innerHours*/
      4096 && button_data_value_value !== (button_data_value_value = /*p*/
      ctx2[36].val)) {
        attr_dev(button, "data-value", button_data_value_value);
      }
      if (!current || dirty[0] & /*startDate, endDate, innerHours*/
      4099 && button_disabled_value !== (button_disabled_value = /*startDate*/
      (ctx2[0] || /*endDate*/
      ctx2[1]) && /*isDisabled*/
      ctx2[16](
        /*p*/
        ctx2[36].val,
        false
      ))) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (!current || dirty[0] & /*showMeridian, isMinuteView*/
      36) {
        toggle_class(
          button,
          "outer-tick",
          /*showMeridian*/
          ctx2[2] && !/*isMinuteView*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*isSelected, isMinuteView, selectedMinutes, selectedHour, innerHours*/
      37088) {
        toggle_class(
          button,
          "is-selected",
          /*isSelected*/
          ctx2[15](
            /*isMinuteView*/
            ctx2[5] ? (
              /*selectedMinutes*/
              ctx2[7]
            ) : (
              /*selectedHour*/
              ctx2[6]
            ),
            /*p*/
            ctx2[36].val,
            /*i*/
            ctx2[38]
          )
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!button_transition)
            button_transition = create_bidirectional_transition(button, fade, { duration: 200 }, true);
          button_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!button_transition)
          button_transition = create_bidirectional_transition(button, fade, { duration: 200 }, false);
        button_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (detaching && button_transition)
        button_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(359:6) {#each innerHours as p, i}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div5;
  let div0;
  let t0;
  let button0;
  let t1_value = (
    /*view*/
    ctx[14](
      /*selectedHour*/
      ctx[6],
      /*showMeridian*/
      ctx[2]
    ) + ""
  );
  let t1;
  let t2;
  let span;
  let t3;
  let t4;
  let button1;
  let t5_value = (
    /*view*/
    ctx[14](
      /*selectedMinutes*/
      ctx[7],
      false
    ) + ""
  );
  let t5;
  let t6;
  let t7;
  let div4;
  let div1;
  let t8;
  let div3;
  let div2;
  let t9;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t10;
  let div5_intro;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*hasDateComponent*/
    ctx[3] && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*showMeridian*/
    ctx[2] && create_if_block2(ctx)
  );
  let each_value_1 = (
    /*pos*/
    ctx[13]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => (
    /*p*/
    ctx2[36].val
  );
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_12(key, child_ctx));
  }
  let each_value = (
    /*innerHours*/
    ctx[12]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div5 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      button0 = element("button");
      t1 = text(t1_value);
      t2 = space();
      span = element("span");
      t3 = text(":");
      t4 = space();
      button1 = element("button");
      t5 = text(t5_value);
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      div4 = element("div");
      div1 = element("div");
      t8 = space();
      div3 = element("div");
      div2 = element("div");
      t9 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t10 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div0 = claim_element(div5_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(button0_nodes, t1_value);
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      span = claim_element(div0_nodes, "SPAN", {});
      var span_nodes = children(span);
      t3 = claim_text(span_nodes, ":");
      span_nodes.forEach(detach_dev);
      t4 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t5 = claim_text(button1_nodes, t5_value);
      button1_nodes.forEach(detach_dev);
      t6 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t7 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div1 = claim_element(div4_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      t8 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t9 = claim_space(div4_nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div4_nodes);
      }
      t10 = claim_space(div4_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div4_nodes);
      }
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", "sdt-time-btn sdt-time-figure svelte-163fzlc");
      toggle_class(button0, "is-active", !/*isMinuteView*/
      ctx[5]);
      add_location(button0, file2, 329, 4, 10276);
      add_location(span, file2, 333, 4, 10460);
      attr_dev(button1, "class", "sdt-time-btn sdt-time-figure svelte-163fzlc");
      toggle_class(
        button1,
        "is-active",
        /*isMinuteView*/
        ctx[5]
      );
      add_location(button1, file2, 334, 4, 10480);
      attr_dev(div0, "class", "sdt-time-head svelte-163fzlc");
      add_location(div0, file2, 323, 2, 9619);
      attr_dev(div1, "class", "sdt-middle-dot svelte-163fzlc");
      add_location(div1, file2, 347, 4, 11138);
      attr_dev(div2, "class", "sdt-hand-circle svelte-163fzlc");
      add_location(div2, file2, 349, 6, 11232);
      attr_dev(div3, "class", "sdt-hand-pointer svelte-163fzlc");
      attr_dev(
        div3,
        "style",
        /*handCss*/
        ctx[10]
      );
      add_location(div3, file2, 348, 4, 11178);
      attr_dev(div4, "class", "sdt-clock svelte-163fzlc");
      add_location(div4, file2, 346, 2, 10948);
      attr_dev(div5, "class", "sdt-timer svelte-163fzlc");
      add_location(div5, file2, 321, 0, 9562);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div0, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t3);
      append_hydration_dev(div0, t4);
      append_hydration_dev(div0, button1);
      append_hydration_dev(button1, t5);
      append_hydration_dev(div0, t6);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div5, t7);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, div1);
      append_hydration_dev(div4, t8);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div4, t9);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div4, null);
        }
      }
      append_hydration_dev(div4, t10);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      ctx[29](div4);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(div4, "click", prevent_default(
            /*onClick*/
            ctx[17]
          ), false, true, false, false),
          listen_dev(
            div4,
            "mousedown",
            /*onToggleMove*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div4,
            "mousemove",
            /*mousemove_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div4,
            "mouseup",
            /*onToggleMove*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*hasDateComponent*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty[0] & /*selectedHour, showMeridian*/
      68) && t1_value !== (t1_value = /*view*/
      ctx2[14](
        /*selectedHour*/
        ctx2[6],
        /*showMeridian*/
        ctx2[2]
      ) + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty[0] & /*isMinuteView*/
      32) {
        toggle_class(button0, "is-active", !/*isMinuteView*/
        ctx2[5]);
      }
      if ((!current || dirty[0] & /*selectedMinutes*/
      128) && t5_value !== (t5_value = /*view*/
      ctx2[14](
        /*selectedMinutes*/
        ctx2[7],
        false
      ) + ""))
        set_data_dev(t5, t5_value);
      if (!current || dirty[0] & /*isMinuteView*/
      32) {
        toggle_class(
          button1,
          "is-active",
          /*isMinuteView*/
          ctx2[5]
        );
      }
      if (
        /*showMeridian*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & /*handCss*/
      1024) {
        attr_dev(
          div3,
          "style",
          /*handCss*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*pos, startDate, endDate, isDisabled, isMinuteView, isSelected, selectedHour*/
      106595) {
        each_value_1 = /*pos*/
        ctx2[13];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_12, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, div4, outro_and_destroy_block, create_each_block_12, t10, get_each_context_12);
        check_outros();
      }
      if (dirty[0] & /*innerHours, startDate, endDate, isDisabled, showMeridian, isMinuteView, isSelected, selectedMinutes, selectedHour*/
      102631) {
        each_value = /*innerHours*/
        ctx2[12];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div4, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (!div5_intro) {
        add_render_callback(() => {
          div5_intro = create_in_transition(div5, fade, { duration: 200 });
          div5_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      destroy_each(each_blocks, detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let selectedHour;
  let isPM;
  let selectedMinutes;
  let multiplier;
  let sameDateRestriction;
  let pos;
  let innerHours;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Time", slots, []);
  let { date = null } = $$props;
  let { startDate = null } = $$props;
  let { endDate = null } = $$props;
  let { minuteIncrement = 1 } = $$props;
  let { showMeridian = false } = $$props;
  let { hasDateComponent = false } = $$props;
  let { i18n } = $$props;
  function minuteSwitch(val) {
    if (val === null)
      return isMinuteView;
    $$invalidate(5, isMinuteView = val);
  }
  function makeTick(val) {
    if (isMinuteView) {
      val = val * 5 + selectedMinutes;
      if (val % 5 !== 0) {
        val = val < selectedMinutes ? val + (5 - val % 5) : val - val % 5;
      }
    } else {
      val = selectedHour + val;
    }
    enableViewToggle = false;
    onClick({
      target: {
        tagName: "BUTTON",
        dataset: { value: val }
      }
    });
    enableViewToggle = true;
  }
  let clockEl;
  let isMinuteView = false;
  let handleMoveMove = false;
  let enableViewToggle = true;
  let innerDate = date || /* @__PURE__ */ new Date();
  if (!date) {
    date = innerDate;
    date.setHours(0, 0, 0, 0);
  }
  let canSelect = true;
  const dispatch = createEventDispatcher();
  let handCss = "";
  function positions(size, offset, valueForZero, minuteView, hourAdded) {
    const r = size / 2;
    offset = offset || r;
    const coeff = [0, 1 - 0.5, 1 - 0.134, 1, 1 - 0.134, 1 - 0.5];
    const xCoeff = coeff.concat(coeff);
    const yCoeff = coeff.slice(3).concat(coeff).concat(coeff.slice(0, 3));
    const pos2 = [];
    for (let i = 0; i < 12; i++) {
      pos2.push({
        x: Math.abs(xCoeff[i] * r + (i <= 6 ? 1 : -1) * offset),
        y: Math.abs(yCoeff[i] * r + (i >= 9 || i < 3 ? -1 : 1) * offset),
        val: minuteView ? i * 5 || valueForZero : i ? i + hourAdded : valueForZero
      });
    }
    return pos2;
  }
  function view(value, asMeridian) {
    if (asMeridian) {
      if (isPM && value === 12)
        return 12;
      return value < 10 || value % 12 < 10 ? `0${value % 12}` : value % 12;
    }
    return value < 10 ? `0${value}` : value;
  }
  function isSelected(selected, val, i) {
    if (isMinuteView) {
      return val === selected || i === 0 && i === selected;
    } else {
      if (showMeridian) {
        if (isPM && val == 12 && selected === 12)
          return true;
        if (!isPM && val == 12 && selected === 0)
          return true;
        return val === (selected ? selected % 12 : 12);
      } else if (val > 12) {
        return (i ? multiplier * i + 12 : 0) === selected;
      } else {
        return val === "00" || val === "12" ? selected === 12 && parseInt(val) == 12 || val === "00" && selected === 0 : val === selected;
      }
    }
  }
  function isDisabled(val, isManualMinuteCheck = false) {
    if (typeof val === "string")
      val = parseInt(val);
    if (startDate && endDate && sameDateRestriction) {
      if (isMinuteView || isManualMinuteCheck) {
        return startDate.getHours() === innerDate.getHours() && startDate.getMinutes() > val || endDate.getHours() === innerDate.getHours() && endDate.getMinutes() < val;
      }
      return startDate.getHours() > val || endDate.getHours() < val;
    }
    if (startDate && startDate.getDate() === innerDate.getDate() && startDate.getMonth() === innerDate.getMonth() && startDate.getFullYear() === innerDate.getFullYear()) {
      if (isMinuteView || isManualMinuteCheck) {
        return startDate.getHours() === innerDate.getHours() && startDate.getMinutes() > val;
      }
      return startDate.getHours() > val;
    }
    if (endDate && endDate.getDate() === innerDate.getDate() && endDate.getMonth() === innerDate.getMonth() && endDate.getFullYear() === innerDate.getFullYear()) {
      if (isMinuteView || isManualMinuteCheck) {
        return endDate.getHours() === innerDate.getHours() && endDate.getMinutes() < val;
      }
      return endDate.getHours() < val;
    }
    return false;
  }
  function onClick(e) {
    if (!canSelect || !e.target)
      return;
    if (e.type === "mousemove" && !handleMoveMove || !isMinuteView && e.target.tagName !== "BUTTON")
      return;
    let a = 0;
    let b = 0;
    if (e.target.tagName === "BUTTON" && (!isMinuteView || minuteIncrement === 1)) {
      let val = parseInt(e.target.dataset.value);
      const setter = !isMinuteView ? "setHours" : "setMinutes";
      if (!isMinuteView && isPM) {
        val += 12;
      }
      innerDate[setter](val);
    } else if (isMinuteView) {
      const rect = clockEl.getBoundingClientRect();
      const clientX = e.clientX - rect.left;
      const clientY = e.clientY - rect.top;
      const cntX = 130, cntY = 130;
      let quadrant = null;
      if (clientX > cntX) {
        quadrant = clientY > cntY ? 2 : 1;
      } else {
        quadrant = clientY > cntY ? 3 : 4;
      }
      switch (quadrant) {
        case 1:
          a = clientX - cntX;
          b = cntY - clientY;
          break;
        case 2:
          a = clientX - cntX;
          b = clientY - cntY;
          break;
        case 3:
          a = cntX - clientX;
          b = clientY - cntY;
          break;
        case 4:
          a = cntX - clientX;
          b = cntY - clientY;
          break;
      }
      const c = Math.sqrt(a * a + b * b);
      const beta = 90 - Math.asin(a / c) * (180 / Math.PI);
      let degree = 0;
      switch (quadrant) {
        case 1:
          degree = 90 - beta;
          break;
        case 2:
          degree = beta + 90;
          break;
        case 3:
          degree = 270 - beta;
          break;
        case 4:
          degree = beta + 270;
          break;
      }
      degree = Math.round(degree / 6 / minuteIncrement) * minuteIncrement;
      if (degree === 60) {
        degree = 0;
      }
      innerDate.setMinutes(degree);
    }
    $$invalidate(25, innerDate), $$invalidate(21, date);
    canSelect = false;
    dispatch("time", innerDate);
    if (!handleMoveMove && isMinuteView)
      setTimeout(
        () => {
          dispatch("close");
        },
        300
      );
    if (enableViewToggle && !isMinuteView)
      $$invalidate(5, isMinuteView = true);
    enableViewToggle = true;
    setTimeout(
      () => {
        enableViewToggle = false;
        canSelect = true;
      },
      200
    );
  }
  function onSwitchMeridian(e) {
    const val = parseInt(e.target.dataset.value);
    innerDate.setHours(val);
    $$invalidate(25, innerDate), $$invalidate(21, date);
    dispatch("time", innerDate);
  }
  function onToggleMove(e) {
    $$invalidate(9, handleMoveMove = e.type === "mousedown");
  }
  function onModeSwitch() {
    dispatch("switch", "date");
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<Time> was created without expected prop 'i18n'");
    }
  });
  const writable_props = [
    "date",
    "startDate",
    "endDate",
    "minuteIncrement",
    "showMeridian",
    "hasDateComponent",
    "i18n"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Time> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(5, isMinuteView = false);
  const click_handler_1 = () => $$invalidate(5, isMinuteView = true);
  const mousemove_handler = (e) => {
    handleMoveMove && onClick(e);
  };
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      clockEl = $$value;
      $$invalidate(8, clockEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(21, date = $$props2.date);
    if ("startDate" in $$props2)
      $$invalidate(0, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(1, endDate = $$props2.endDate);
    if ("minuteIncrement" in $$props2)
      $$invalidate(22, minuteIncrement = $$props2.minuteIncrement);
    if ("showMeridian" in $$props2)
      $$invalidate(2, showMeridian = $$props2.showMeridian);
    if ("hasDateComponent" in $$props2)
      $$invalidate(3, hasDateComponent = $$props2.hasDateComponent);
    if ("i18n" in $$props2)
      $$invalidate(4, i18n = $$props2.i18n);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tick,
    fade,
    date,
    startDate,
    endDate,
    minuteIncrement,
    showMeridian,
    hasDateComponent,
    i18n,
    minuteSwitch,
    makeTick,
    clockEl,
    isMinuteView,
    handleMoveMove,
    enableViewToggle,
    innerDate,
    canSelect,
    dispatch,
    handCss,
    positions,
    view,
    isSelected,
    isDisabled,
    onClick,
    onSwitchMeridian,
    onToggleMove,
    onModeSwitch,
    isPM,
    sameDateRestriction,
    multiplier,
    innerHours,
    pos,
    selectedHour,
    selectedMinutes
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(21, date = $$props2.date);
    if ("startDate" in $$props2)
      $$invalidate(0, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(1, endDate = $$props2.endDate);
    if ("minuteIncrement" in $$props2)
      $$invalidate(22, minuteIncrement = $$props2.minuteIncrement);
    if ("showMeridian" in $$props2)
      $$invalidate(2, showMeridian = $$props2.showMeridian);
    if ("hasDateComponent" in $$props2)
      $$invalidate(3, hasDateComponent = $$props2.hasDateComponent);
    if ("i18n" in $$props2)
      $$invalidate(4, i18n = $$props2.i18n);
    if ("clockEl" in $$props2)
      $$invalidate(8, clockEl = $$props2.clockEl);
    if ("isMinuteView" in $$props2)
      $$invalidate(5, isMinuteView = $$props2.isMinuteView);
    if ("handleMoveMove" in $$props2)
      $$invalidate(9, handleMoveMove = $$props2.handleMoveMove);
    if ("enableViewToggle" in $$props2)
      enableViewToggle = $$props2.enableViewToggle;
    if ("innerDate" in $$props2)
      $$invalidate(25, innerDate = $$props2.innerDate);
    if ("canSelect" in $$props2)
      canSelect = $$props2.canSelect;
    if ("handCss" in $$props2)
      $$invalidate(10, handCss = $$props2.handCss);
    if ("isPM" in $$props2)
      $$invalidate(11, isPM = $$props2.isPM);
    if ("sameDateRestriction" in $$props2)
      sameDateRestriction = $$props2.sameDateRestriction;
    if ("multiplier" in $$props2)
      multiplier = $$props2.multiplier;
    if ("innerHours" in $$props2)
      $$invalidate(12, innerHours = $$props2.innerHours);
    if ("pos" in $$props2)
      $$invalidate(13, pos = $$props2.pos);
    if ("selectedHour" in $$props2)
      $$invalidate(6, selectedHour = $$props2.selectedHour);
    if ("selectedMinutes" in $$props2)
      $$invalidate(7, selectedMinutes = $$props2.selectedMinutes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*date, innerDate*/
    35651584) {
      $: {
        if (date !== innerDate && date) {
          $$invalidate(25, innerDate = date);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*startDate, innerDate, endDate*/
    33554435) {
      $: {
        let forceTimeUpdate = false;
        if (startDate && startDate.toDateString() === innerDate.toDateString()) {
          if (isDisabled(innerDate.getHours())) {
            innerDate.setHours(startDate.getHours());
            forceTimeUpdate = true;
          }
          if (isDisabled(innerDate.getMinutes(), true)) {
            innerDate.setMinutes(startDate.getMinutes());
            forceTimeUpdate = true;
          }
        }
        if (endDate && endDate.toDateString() === innerDate.toDateString()) {
          if (isDisabled(innerDate.getHours())) {
            innerDate.setHours(endDate.getHours());
            forceTimeUpdate = true;
          }
          if (isDisabled(innerDate.getMinutes(), true)) {
            innerDate.setMinutes(endDate.getMinutes());
            forceTimeUpdate = true;
          }
        }
        forceTimeUpdate && tick().then(() => dispatch("time", innerDate));
      }
    }
    if ($$self.$$.dirty[0] & /*innerDate*/
    33554432) {
      $:
        $$invalidate(6, selectedHour = innerDate ? innerDate.getHours() : 0);
    }
    if ($$self.$$.dirty[0] & /*showMeridian, selectedHour*/
    68) {
      $:
        $$invalidate(11, isPM = showMeridian ? selectedHour >= 12 : false);
    }
    if ($$self.$$.dirty[0] & /*innerDate*/
    33554432) {
      $:
        $$invalidate(7, selectedMinutes = innerDate ? innerDate.getMinutes() : 0);
    }
    if ($$self.$$.dirty[0] & /*isMinuteView, selectedMinutes, selectedHour, showMeridian*/
    228) {
      $: {
        let nextDegree = isMinuteView ? selectedMinutes * 6 : selectedHour % 12 * 30;
        $$invalidate(10, handCss = isMinuteView || showMeridian || selectedHour < 12 ? `transform: rotateZ(${nextDegree}deg);` : `transform: rotateZ(${nextDegree}deg); height: calc(25% + 1px)`);
      }
    }
    if ($$self.$$.dirty[0] & /*isMinuteView*/
    32) {
      $:
        multiplier = isMinuteView ? 5 : 1;
    }
    if ($$self.$$.dirty[0] & /*startDate, endDate*/
    3) {
      $:
        sameDateRestriction = startDate && endDate && ["getFullYear", "getMonth", "getDate"].every((p) => endDate[p]() === startDate[p]());
    }
    if ($$self.$$.dirty[0] & /*isMinuteView*/
    32) {
      $:
        $$invalidate(13, pos = positions(isMinuteView ? 260 : 220, 130, "00", false, 0));
    }
    if ($$self.$$.dirty[0] & /*isMinuteView*/
    32) {
      $:
        $$invalidate(12, innerHours = positions(isMinuteView ? 220 : 140, 130, isMinuteView ? "00" : "12", isMinuteView, 12));
    }
    if ($$self.$$.dirty[0] & /*isMinuteView*/
    32) {
      $: {
        dispatch("time-switch", isMinuteView);
      }
    }
  };
  return [
    startDate,
    endDate,
    showMeridian,
    hasDateComponent,
    i18n,
    isMinuteView,
    selectedHour,
    selectedMinutes,
    clockEl,
    handleMoveMove,
    handCss,
    isPM,
    innerHours,
    pos,
    view,
    isSelected,
    isDisabled,
    onClick,
    onSwitchMeridian,
    onToggleMove,
    onModeSwitch,
    date,
    minuteIncrement,
    minuteSwitch,
    makeTick,
    innerDate,
    click_handler,
    click_handler_1,
    mousemove_handler,
    div4_binding
  ];
}
var Time = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        date: 21,
        startDate: 0,
        endDate: 1,
        minuteIncrement: 22,
        showMeridian: 2,
        hasDateComponent: 3,
        i18n: 4,
        minuteSwitch: 23,
        makeTick: 24
      },
      add_css2,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Time",
      options,
      id: create_fragment2.name
    });
  }
  get date() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startDate() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startDate(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endDate() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endDate(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minuteIncrement() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minuteIncrement(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showMeridian() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showMeridian(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasDateComponent() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasDateComponent(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minuteSwitch() {
    return this.$$.ctx[23];
  }
  set minuteSwitch(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get makeTick() {
    return this.$$.ctx[24];
  }
  set makeTick(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Time_default = Time;

// node_modules/svelty-picker/components/SveltyPicker.svelte
var file3 = "node_modules/svelty-picker/components/SveltyPicker.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1t6pprq", ".sdt-calendar-colors.svelte-1t6pprq{--sdt-primary:#286090;--sdt-color:#000;--sdt-bg-main:#fff;--sdt-bg-today:var(--sdt-primary);--sdt-bg-clear:#dc3545;--sdt-today-bg:#1e486d;--sdt-clear-color:#dc3545;--sdt-btn-bg-hover:#eee;--sdt-btn-header-bg-hover:#dfdfdf;--sdt-clock-bg:#eeeded;--sdt-shadow:#ccc;--sdt-disabled-date:#b22222}.std-calendar-wrap.svelte-1t6pprq{width:280px;background-color:var(--sdt-bg-main);box-shadow:0 1px 6px var(--sdt-shadow);border-radius:4px;padding:0.25rem 0.25rem 0.5rem;color:var(--sdt-color)}.std-calendar-wrap.is-popup.svelte-1t6pprq{box-shadow:0 1px 6px var(--sdt-shadow)}.std-btn-row.svelte-1t6pprq{margin-top:0.5rem;display:flex;justify-content:space-evenly}.sdt-action-btn.svelte-1t6pprq{padding:0.25rem 0.5rem;font-size:0.875rem;border-radius:0.2rem}.sdt-today-btn.svelte-1t6pprq{background-color:var(--sdt-primary);color:var(--sdt-today-color, var(--sdt-bg-main));padding:0.25rem 0.5rem;font-size:0.875rem;border-radius:0.2rem;border:1px solid var(--sdt-today-bg)}.sdt-today-btn[disabled].svelte-1t6pprq{opacity:0.5;cursor:not-allowed}.sdt-today-btn.svelte-1t6pprq:focus,.sdt-today-btn.svelte-1t6pprq:active,.sdt-today-btn.svelte-1t6pprq:hover:not([disabled]){background-color:var(--sdt-today-bg)}.sdt-clear-btn.svelte-1t6pprq{border:1px solid var(--sdt-clear-color);background-color:transparent;color:var(--sdt-clear-color)}.sdt-clear-btn.svelte-1t6pprq:focus,.sdt-clear-btn.svelte-1t6pprq:active:not([disabled]),.sdt-clear-btn.svelte-1t6pprq:hover:not([disabled]){background-color:var(--sdt-clear-color);color:var(--sdt-clear-hover-color, var(--sdt-bg-main))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHR5UGlja2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtYkEsbUNBQXFCLENBQ25CLGFBQWEsQ0FBRSxPQUFPLENBQ3RCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGFBQWEsQ0FBRSxJQUFJLENBQ25CLGNBQWMsQ0FBRSxrQkFBa0IsQ0FDbEMsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsaUJBQWlCLENBQUUsT0FBTyxDQUMxQixrQkFBa0IsQ0FBRSxJQUFJLENBQ3hCLHlCQUF5QixDQUFFLE9BQU8sQ0FDbEMsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsWUFBWSxDQUFFLElBQUksQ0FDbEIsbUJBQW1CLENBQUUsT0FDdkIsQ0FDQSxpQ0FBbUIsQ0FDakIsS0FBSyxDQUFFLEtBQUssQ0FDWixnQkFBZ0IsQ0FBRSxJQUFJLGFBQWEsQ0FBQyxDQUNwQyxVQUFVLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FDdkMsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUMvQixLQUFLLENBQUUsSUFBSSxXQUFXLENBQ3hCLENBQ0Esa0JBQWtCLHdCQUFVLENBQzFCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FDeEMsQ0FDQSwyQkFBYSxDQUNYLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLFlBQ25CLENBQ0EsOEJBQWdCLENBQ2QsT0FBTyxDQUFFLE9BQU8sQ0FBQyxNQUFNLENBQ3ZCLFNBQVMsQ0FBRSxRQUFRLENBQ25CLGFBQWEsQ0FBRSxNQUNqQixDQUNBLDZCQUFlLENBQ2IsZ0JBQWdCLENBQUUsSUFBSSxhQUFhLENBQUMsQ0FDcEMsS0FBSyxDQUFFLElBQUksaUJBQWlCLENBQUMsbUJBQW1CLENBQUMsQ0FDakQsT0FBTyxDQUFFLE9BQU8sQ0FBQyxNQUFNLENBQ3ZCLFNBQVMsQ0FBRSxRQUFRLENBQ25CLGFBQWEsQ0FBRSxNQUFNLENBQ3JCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksY0FBYyxDQUN0QyxDQUNBLGNBQWMsQ0FBQyxRQUFRLGdCQUFFLENBQ3ZCLE9BQU8sQ0FBRSxHQUFHLENBQ1osTUFBTSxDQUFFLFdBQ1YsQ0FDQSw2QkFBYyxNQUFNLENBQUUsNkJBQWMsT0FBTyxDQUFFLDZCQUFjLE1BQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFFLENBQ2hGLGdCQUFnQixDQUFFLElBQUksY0FBYyxDQUN0QyxDQUNBLDZCQUFlLENBQ2IsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxDQUN4QyxnQkFBZ0IsQ0FBRSxXQUFXLENBQzdCLEtBQUssQ0FBRSxJQUFJLGlCQUFpQixDQUM5QixDQUNBLDZCQUFjLE1BQU0sQ0FBRSw2QkFBYyxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFFLDZCQUFjLE1BQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFFLENBQ2hHLGdCQUFnQixDQUFFLElBQUksaUJBQWlCLENBQUMsQ0FDeEMsS0FBSyxDQUFFLElBQUksdUJBQXVCLENBQUMsbUJBQW1CLENBQ3hEIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN2ZWx0eVBpY2tlci5zdmVsdGUiXX0= */");
}
function create_if_block_5(ctx) {
  let input;
  let input_type_value;
  let input_class_value;
  let inputAction_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        inputmode: true,
        tabindex: true,
        name: true,
        placeholder: true,
        autocomplete: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", input_type_value = /*pickerOnly*/
      ctx[8] ? "hidden" : "text");
      attr_dev(
        input,
        "id",
        /*inputId*/
        ctx[3]
      );
      attr_dev(input, "inputmode", "none");
      attr_dev(input, "tabindex", "0");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.disabled = /*disabled*/
      ctx[5];
      input.required = /*required*/
      ctx[7];
      input.value = /*value*/
      ctx[1];
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[6]
      );
      attr_dev(input, "autocomplete", "off");
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*inputClasses*/
        ctx[14]
      ) + " svelte-1t6pprq");
      input.readOnly = /*isFocused*/
      ctx[22];
      add_location(input, file3, 357, 0, 10352);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[60](input);
      if (!mounted) {
        dispose = [
          action_destroyer(inputAction_action = /*inputAction*/
          ctx[35].call(
            null,
            input,
            /*inputActionParams*/
            ctx[36]
          )),
          listen_dev(
            input,
            "focus",
            /*onInputFocus*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onInputBlur*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[61],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[58],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[59],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[40],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*pickerOnly*/
      256 && input_type_value !== (input_type_value = /*pickerOnly*/
      ctx2[8] ? "hidden" : "text")) {
        attr_dev(input, "type", input_type_value);
      }
      if (dirty[0] & /*inputId*/
      8) {
        attr_dev(
          input,
          "id",
          /*inputId*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*required*/
      128) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*placeholder*/
      64) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*inputClasses*/
      16384 && input_class_value !== (input_class_value = null_to_empty(
        /*inputClasses*/
        ctx2[14]
      ) + " svelte-1t6pprq")) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty[0] & /*isFocused*/
      4194304) {
        prop_dev(
          input,
          "readOnly",
          /*isFocused*/
          ctx2[22]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[60](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(357:0) {#if !inputElement}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let positionFn_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_13, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*currentMode*/
      ctx2[24] === "date"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "std-calendar-wrap is-popup " + /*theme*/
      ctx[9] + " svelte-1t6pprq");
      add_location(div, file3, 377, 2, 10850);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(positionFn_action = /*positionFn*/
          ctx[20].call(null, div, {
            inputEl: (
              /*inputEl*/
              ctx[28]
            ),
            visible: (
              /*internalVisibility*/
              ctx[32]
            ),
            inputRect: (
              /*inputRect*/
              ctx[29]
            )
          })),
          listen_dev(div, "mousedown", prevent_default(
            /*mousedown_handler*/
            ctx[57]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*theme*/
      512 && div_class_value !== (div_class_value = "std-calendar-wrap is-popup " + /*theme*/
      ctx2[9] + " svelte-1t6pprq")) {
        attr_dev(div, "class", div_class_value);
      }
      if (positionFn_action && is_function(positionFn_action.update) && dirty[0] & /*inputEl, inputRect*/
      805306368 | dirty[1] & /*internalVisibility*/
      2)
        positionFn_action.update.call(null, {
          inputEl: (
            /*inputEl*/
            ctx2[28]
          ),
          visible: (
            /*internalVisibility*/
            ctx2[32]
          ),
          inputRect: (
            /*inputRect*/
            ctx2[29]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              /*fadeFn*/
              ctx[33],
              { duration: 200 },
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            /*fadeFn*/
            ctx[33],
            { duration: 200 },
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(377:0) {#if pickerVisible && isFocused }",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let time;
  let current;
  let time_props = {
    date: (
      /*innerDate*/
      ctx[21]
    ),
    startDate: (
      /*parsedStartDate*/
      ctx[26]
    ),
    endDate: (
      /*parsedEndDate*/
      ctx[27]
    ),
    hasDateComponent: (
      /*resolvedMode*/
      ctx[23] !== "time"
    ),
    showMeridian: (
      /*format*/
      ctx[10].match(
        /*formatType*/
        ctx[11] === "php" ? "a|A" : "p|P"
      ) !== null
    ),
    i18n: (
      /*i18n*/
      ctx[19]
    ),
    minuteIncrement: (
      /*minuteIncrement*/
      ctx[12]
    )
  };
  time = new Time_default({ props: time_props, $$inline: true });
  ctx[63](time);
  time.$on(
    "time",
    /*onDate*/
    ctx[37]
  );
  time.$on(
    "switch",
    /*onModeSwitch*/
    ctx[41]
  );
  time.$on(
    "close",
    /*onTimeClose*/
    ctx[42]
  );
  time.$on(
    "time-switch",
    /*onTimeSwitch*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(time.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(time.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(time, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const time_changes = {};
      if (dirty[0] & /*innerDate*/
      2097152)
        time_changes.date = /*innerDate*/
        ctx2[21];
      if (dirty[0] & /*parsedStartDate*/
      67108864)
        time_changes.startDate = /*parsedStartDate*/
        ctx2[26];
      if (dirty[0] & /*parsedEndDate*/
      134217728)
        time_changes.endDate = /*parsedEndDate*/
        ctx2[27];
      if (dirty[0] & /*resolvedMode*/
      8388608)
        time_changes.hasDateComponent = /*resolvedMode*/
        ctx2[23] !== "time";
      if (dirty[0] & /*format, formatType*/
      3072)
        time_changes.showMeridian = /*format*/
        ctx2[10].match(
          /*formatType*/
          ctx2[11] === "php" ? "a|A" : "p|P"
        ) !== null;
      if (dirty[0] & /*i18n*/
      524288)
        time_changes.i18n = /*i18n*/
        ctx2[19];
      if (dirty[0] & /*minuteIncrement*/
      4096)
        time_changes.minuteIncrement = /*minuteIncrement*/
        ctx2[12];
      time.$set(time_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(time.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(time.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[63](null);
      destroy_component(time, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(416:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  var _a;
  let calendar;
  let t;
  let if_block_anchor;
  let current;
  let calendar_props = {
    date: (
      /*innerDate*/
      ctx[21]
    ),
    startDate: (
      /*parsedStartDate*/
      ctx[26]
    ),
    endDate: (
      /*parsedEndDate*/
      ctx[27]
    ),
    enableTimeToggle: (
      /*resolvedMode*/
      (_a = ctx[23]) == null ? void 0 : _a.includes("time")
    ),
    initialView: (
      /*startView*/
      ctx[2] > 2 ? 2 : (
        /*startView*/
        ctx[2]
      )
    ),
    i18n: (
      /*i18n*/
      ctx[19]
    ),
    weekStart: (
      /*weekStart*/
      ctx[13]
    )
  };
  calendar = new Calendar_default({ props: calendar_props, $$inline: true });
  ctx[62](calendar);
  calendar.$on(
    "date",
    /*onDate*/
    ctx[37]
  );
  calendar.$on(
    "switch",
    /*onModeSwitch*/
    ctx[41]
  );
  let if_block = (
    /*todayBtn*/
    (ctx[17] || /*clearBtn*/
    ctx[18]) && create_if_block_22(ctx)
  );
  const block = {
    c: function create() {
      create_component(calendar.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(calendar.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(calendar, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      const calendar_changes = {};
      if (dirty[0] & /*innerDate*/
      2097152)
        calendar_changes.date = /*innerDate*/
        ctx2[21];
      if (dirty[0] & /*parsedStartDate*/
      67108864)
        calendar_changes.startDate = /*parsedStartDate*/
        ctx2[26];
      if (dirty[0] & /*parsedEndDate*/
      134217728)
        calendar_changes.endDate = /*parsedEndDate*/
        ctx2[27];
      if (dirty[0] & /*resolvedMode*/
      8388608)
        calendar_changes.enableTimeToggle = /*resolvedMode*/
        (_a2 = ctx2[23]) == null ? void 0 : _a2.includes("time");
      if (dirty[0] & /*startView*/
      4)
        calendar_changes.initialView = /*startView*/
        ctx2[2] > 2 ? 2 : (
          /*startView*/
          ctx2[2]
        );
      if (dirty[0] & /*i18n*/
      524288)
        calendar_changes.i18n = /*i18n*/
        ctx2[19];
      if (dirty[0] & /*weekStart*/
      8192)
        calendar_changes.weekStart = /*weekStart*/
        ctx2[13];
      calendar.$set(calendar_changes);
      if (
        /*todayBtn*/
        ctx2[17] || /*clearBtn*/
        ctx2[18]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[62](null);
      destroy_component(calendar, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: '(384:4) {#if currentMode === \\"date\\"}',
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let t;
  let if_block0 = (
    /*todayBtn*/
    ctx[17] && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*clearBtn*/
    ctx[18] && create_if_block_32(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "std-btn-row svelte-1t6pprq");
      add_location(div, file3, 397, 8, 11505);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*todayBtn*/
        ctx2[17]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*clearBtn*/
        ctx2[18]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_32(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(397:6) {#if todayBtn || clearBtn}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button;
  let t_value = (
    /*i18n*/
    ctx[19].todayBtn + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*todayBtnClasses*/
        ctx[15]
      ) + " svelte-1t6pprq");
      button.disabled = /*isTodayDisabled*/
      ctx[34];
      add_location(button, file3, 399, 12, 11570);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onToday*/
          ctx[38],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n*/
      524288 && t_value !== (t_value = /*i18n*/
      ctx2[19].todayBtn + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*todayBtnClasses*/
      32768 && button_class_value !== (button_class_value = null_to_empty(
        /*todayBtnClasses*/
        ctx2[15]
      ) + " svelte-1t6pprq")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[1] & /*isTodayDisabled*/
      8) {
        prop_dev(
          button,
          "disabled",
          /*isTodayDisabled*/
          ctx2[34]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(399:10) {#if todayBtn}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let button;
  let t_value = (
    /*i18n*/
    ctx[19].clearBtn + ""
  );
  let t;
  let button_class_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*clearBtnClasses*/
        ctx[16]
      ) + " svelte-1t6pprq");
      button.disabled = button_disabled_value = !/*innerDate*/
      ctx[21];
      add_location(button, file3, 407, 12, 11804);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onClear*/
          ctx[39],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n*/
      524288 && t_value !== (t_value = /*i18n*/
      ctx2[19].clearBtn + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*clearBtnClasses*/
      65536 && button_class_value !== (button_class_value = null_to_empty(
        /*clearBtnClasses*/
        ctx2[16]
      ) + " svelte-1t6pprq")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*innerDate*/
      2097152 && button_disabled_value !== (button_disabled_value = !/*innerDate*/
      ctx2[21])) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(407:10) {#if clearBtn}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = !/*inputElement*/
  ctx[0] && create_if_block_5(ctx);
  let if_block1 = (
    /*pickerVisible*/
    ctx[25] && /*isFocused*/
    ctx[22] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*inputElement*/
      ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*pickerVisible*/
        ctx2[25] && /*isFocused*/
        ctx2[22]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*pickerVisible, isFocused*/
          37748736) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var config = settings_default;
function instance3($$self, $$props, $$invalidate) {
  let parsedStartDate;
  let parsedEndDate;
  let isTodayDisabled;
  let pickerVisible;
  let fadeFn;
  let internalVisibility;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SveltyPicker", slots, []);
  let { inputId = "" } = $$props;
  let { name = "date" } = $$props;
  let { disabled = false } = $$props;
  let { placeholder = null } = $$props;
  let { required = false } = $$props;
  let { inputElement = null } = $$props;
  let { value = null } = $$props;
  let { initialDate = null } = $$props;
  let { startDate = null } = $$props;
  let { endDate = null } = $$props;
  let { pickerOnly = false } = $$props;
  let { startView = MODE_MONTH } = $$props;
  let { theme = config.theme } = $$props;
  let { mode = config.mode } = $$props;
  let { format = config.format } = $$props;
  let { formatType = config.formatType } = $$props;
  let { minuteIncrement = config.minuteIncrement } = $$props;
  let { weekStart = config.weekStart } = $$props;
  let { inputClasses = config.inputClasses } = $$props;
  let { todayBtnClasses = config.todayBtnClasses } = $$props;
  let { clearBtnClasses = config.clearBtnClasses } = $$props;
  let { todayBtn = config.todayBtn } = $$props;
  let { clearBtn = config.clearBtn } = $$props;
  let { clearToggle = config.clearToggle } = $$props;
  let { autoclose = config.autoclose } = $$props;
  let { i18n = config.i18n } = $$props;
  let { positionFn = usePosition } = $$props;
  let { validatorAction = null } = $$props;
  function setDateValue(val) {
    $$invalidate(21, innerDate = parseDate(val, format, i18n, formatType));
  }
  function getLastPickerPhase() {
    return lastPickerPhase;
  }
  const dispatch = createEventDispatcher();
  if (value)
    value = value.replace(/(:\d+):\d+/, "$1");
  let prevValue = value;
  let currentFormat = format;
  let innerDate = initialDate && initialDate instanceof Date ? initialDate : value ? parseDate(value, format, i18n, formatType) : null;
  if (innerDate && initialDate) {
    value = formatDate(innerDate, format, i18n, formatType);
  }
  let isFocused = pickerOnly;
  let inputEl = inputElement;
  let inputRect = null;
  let inputAction = validatorAction ? validatorAction.shift() : () => {
  };
  let inputActionParams = validatorAction || [];
  let calendarEl;
  let timeEl;
  let preventClose = false;
  let preventCloseTimer = null;
  let resolvedMode = startView ? startView === 3 ? "time" : "" : "";
  let currentMode = resolvedMode === "time" ? "time" : "date";
  let isMinuteView = false;
  let lastPickerPhase = null;
  function resetView() {
    $$invalidate(2, startView = MODE_MONTH);
    isMinuteView = false;
    if (!pickerOnly)
      $$invalidate(25, pickerVisible = false);
    if (resolvedMode !== "time")
      $$invalidate(24, currentMode = "date");
  }
  function onDate(e) {
    let setter = e.detail || null;
    if (currentMode === "date") {
      lastPickerPhase = "date";
    } else {
      lastPickerPhase = isMinuteView ? "minute" : "hour";
    }
    if (e.detail && innerDate) {
      if (innerDate.getFullYear() === e.detail.getFullYear() && innerDate.getMonth() === e.detail.getMonth() && innerDate.getDate() === e.detail.getDate() && resolvedMode === "date" && clearToggle)
        setter = null;
    }
    $$invalidate(1, value = setter ? formatDate(setter, format, i18n, formatType) : null);
    if (autoclose && (resolvedMode === "date" || !setter) && !pickerOnly && !preventClose) {
      resetView();
    }
    if (setter && !preventClose && resolvedMode === "datetime" && currentMode === "date") {
      $$invalidate(24, currentMode = "time");
    }
    if (preventClose && currentMode === "time") {
      preventCloseTimer = setTimeout(
        () => {
          preventClose = false;
        },
        400
      );
    } else {
      preventClose = false;
    }
    tick().then(() => {
      if (inputElement)
        $$invalidate(0, inputElement.value = value || "", inputElement);
      inputEl && inputEl.dispatchEvent(new Event("input"));
      dispatch("change", value);
    });
  }
  function onToday() {
    const today = /* @__PURE__ */ new Date();
    if (parsedStartDate && parsedStartDate > today)
      return;
    const todayHours = innerDate ? innerDate.getHours() : today.getHours();
    const todayMinutes = innerDate ? innerDate.getMinutes() : today.getMinutes();
    onDate(new CustomEvent(
      "ontoday",
      {
        detail: new Date(today.getFullYear(), today.getMonth(), today.getDate(), todayHours, todayMinutes, 0)
      }
    ));
  }
  function onClear() {
    onDate(new CustomEvent("clear", { detail: null }));
  }
  function onKeyDown(e) {
    if (!pickerVisible) {
      ["Backspace", "Delete"].includes(e.key) && onClear();
      if (e.key === "Enter")
        onInputFocus();
    }
    if (!pickerVisible && e.key !== "Tab") {
      $$invalidate(25, pickerVisible = e.key !== "Shift");
      e.preventDefault();
      return;
    }
    switch (e.key) {
      case "PageDown":
      case "PageUp":
      case "ArrowDown":
      case "ArrowUp":
      case "ArrowLeft":
      case "ArrowRight":
        e.preventDefault();
        preventCloseTimer && clearTimeout(preventCloseTimer);
        preventClose = true;
        if (currentMode === "date") {
          calendarEl.handleGridNav(e.key, e.shiftKey);
        } else {
          timeEl.makeTick(["ArrowDown", "ArrowLeft", "PageDown"].includes(e.key) ? -1 : 1);
        }
        break;
      case "Escape":
        if (isFocused) {
          $$invalidate(25, pickerVisible = false);
        }
        break;
      case "Backspace":
      case "Delete":
        onClear();
        break;
      case "Enter":
        isFocused && e.preventDefault();
        if (currentMode === "time") {
          if (!timeEl.minuteSwitch(null)) {
            return timeEl.minuteSwitch(true);
          }
          return resetView();
        }
        if (isFocused && resolvedMode === "date")
          $$invalidate(25, pickerVisible = false);
        if (innerDate && resolvedMode.includes("time")) {
          $$invalidate(24, currentMode = "time");
        }
        break;
      case "Tab":
        if (pickerVisible) {
          $$invalidate(25, pickerVisible = false);
          e.preventDefault();
        }
      case "F5":
        break;
      default:
        e.preventDefault();
    }
  }
  function onModeSwitch(e) {
    $$invalidate(2, startView = MODE_MONTH);
    $$invalidate(24, currentMode = e.detail);
    isMinuteView = false;
  }
  function onTimeClose() {
    autoclose && !preventClose && resetView();
  }
  function onInputFocus() {
    $$invalidate(29, inputRect = inputEl && inputEl.getBoundingClientRect());
    $$invalidate(22, isFocused = true);
    $$invalidate(25, pickerVisible = true);
  }
  function onInputBlur() {
    $$invalidate(22, isFocused = false);
    $$invalidate(25, pickerVisible = false);
    !inputElement && dispatch("blur");
  }
  function onTimeSwitch(e) {
    isMinuteView = e.detail;
  }
  onMount(() => {
    if (inputElement) {
      $$invalidate(0, inputElement.onfocus = onInputFocus, inputElement);
      $$invalidate(0, inputElement.onblur = onInputBlur, inputElement);
      $$invalidate(0, inputElement.onclick = () => !pickerVisible && onInputFocus(), inputElement);
      $$invalidate(0, inputElement.onkeydown = onKeyDown, inputElement);
    }
  });
  const writable_props = [
    "inputId",
    "name",
    "disabled",
    "placeholder",
    "required",
    "inputElement",
    "value",
    "initialDate",
    "startDate",
    "endDate",
    "pickerOnly",
    "startView",
    "theme",
    "mode",
    "format",
    "formatType",
    "minuteIncrement",
    "weekStart",
    "inputClasses",
    "todayBtnClasses",
    "clearBtnClasses",
    "todayBtn",
    "clearBtn",
    "clearToggle",
    "autoclose",
    "i18n",
    "positionFn",
    "validatorAction"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SveltyPicker> was created with unknown prop '${key}'`);
  });
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(28, inputEl);
    });
  }
  const click_handler = () => {
    !pickerVisible && onInputFocus();
  };
  function calendar_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      calendarEl = $$value;
      $$invalidate(30, calendarEl);
    });
  }
  function time_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      timeEl = $$value;
      $$invalidate(31, timeEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("inputId" in $$props2)
      $$invalidate(3, inputId = $$props2.inputId);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("placeholder" in $$props2)
      $$invalidate(6, placeholder = $$props2.placeholder);
    if ("required" in $$props2)
      $$invalidate(7, required = $$props2.required);
    if ("inputElement" in $$props2)
      $$invalidate(0, inputElement = $$props2.inputElement);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("initialDate" in $$props2)
      $$invalidate(46, initialDate = $$props2.initialDate);
    if ("startDate" in $$props2)
      $$invalidate(47, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(48, endDate = $$props2.endDate);
    if ("pickerOnly" in $$props2)
      $$invalidate(8, pickerOnly = $$props2.pickerOnly);
    if ("startView" in $$props2)
      $$invalidate(2, startView = $$props2.startView);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("mode" in $$props2)
      $$invalidate(49, mode = $$props2.mode);
    if ("format" in $$props2)
      $$invalidate(10, format = $$props2.format);
    if ("formatType" in $$props2)
      $$invalidate(11, formatType = $$props2.formatType);
    if ("minuteIncrement" in $$props2)
      $$invalidate(12, minuteIncrement = $$props2.minuteIncrement);
    if ("weekStart" in $$props2)
      $$invalidate(13, weekStart = $$props2.weekStart);
    if ("inputClasses" in $$props2)
      $$invalidate(14, inputClasses = $$props2.inputClasses);
    if ("todayBtnClasses" in $$props2)
      $$invalidate(15, todayBtnClasses = $$props2.todayBtnClasses);
    if ("clearBtnClasses" in $$props2)
      $$invalidate(16, clearBtnClasses = $$props2.clearBtnClasses);
    if ("todayBtn" in $$props2)
      $$invalidate(17, todayBtn = $$props2.todayBtn);
    if ("clearBtn" in $$props2)
      $$invalidate(18, clearBtn = $$props2.clearBtn);
    if ("clearToggle" in $$props2)
      $$invalidate(50, clearToggle = $$props2.clearToggle);
    if ("autoclose" in $$props2)
      $$invalidate(51, autoclose = $$props2.autoclose);
    if ("i18n" in $$props2)
      $$invalidate(19, i18n = $$props2.i18n);
    if ("positionFn" in $$props2)
      $$invalidate(20, positionFn = $$props2.positionFn);
    if ("validatorAction" in $$props2)
      $$invalidate(52, validatorAction = $$props2.validatorAction);
  };
  $$self.$capture_state = () => ({
    settings: settings_default,
    config,
    createEventDispatcher,
    onMount,
    tick,
    fade,
    Calendar: Calendar_default,
    Time: Time_default,
    formatDate,
    MODE_MONTH,
    parseDate,
    usePosition,
    inputId,
    name,
    disabled,
    placeholder,
    required,
    inputElement,
    value,
    initialDate,
    startDate,
    endDate,
    pickerOnly,
    startView,
    theme,
    mode,
    format,
    formatType,
    minuteIncrement,
    weekStart,
    inputClasses,
    todayBtnClasses,
    clearBtnClasses,
    todayBtn,
    clearBtn,
    clearToggle,
    autoclose,
    i18n,
    positionFn,
    validatorAction,
    setDateValue,
    getLastPickerPhase,
    dispatch,
    prevValue,
    currentFormat,
    innerDate,
    isFocused,
    inputEl,
    inputRect,
    inputAction,
    inputActionParams,
    calendarEl,
    timeEl,
    preventClose,
    preventCloseTimer,
    resolvedMode,
    currentMode,
    isMinuteView,
    lastPickerPhase,
    resetView,
    onDate,
    onToday,
    onClear,
    onKeyDown,
    onModeSwitch,
    onTimeClose,
    onInputFocus,
    onInputBlur,
    onTimeSwitch,
    pickerVisible,
    parsedStartDate,
    internalVisibility,
    fadeFn,
    parsedEndDate,
    isTodayDisabled
  });
  $$self.$inject_state = ($$props2) => {
    if ("inputId" in $$props2)
      $$invalidate(3, inputId = $$props2.inputId);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("placeholder" in $$props2)
      $$invalidate(6, placeholder = $$props2.placeholder);
    if ("required" in $$props2)
      $$invalidate(7, required = $$props2.required);
    if ("inputElement" in $$props2)
      $$invalidate(0, inputElement = $$props2.inputElement);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("initialDate" in $$props2)
      $$invalidate(46, initialDate = $$props2.initialDate);
    if ("startDate" in $$props2)
      $$invalidate(47, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(48, endDate = $$props2.endDate);
    if ("pickerOnly" in $$props2)
      $$invalidate(8, pickerOnly = $$props2.pickerOnly);
    if ("startView" in $$props2)
      $$invalidate(2, startView = $$props2.startView);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("mode" in $$props2)
      $$invalidate(49, mode = $$props2.mode);
    if ("format" in $$props2)
      $$invalidate(10, format = $$props2.format);
    if ("formatType" in $$props2)
      $$invalidate(11, formatType = $$props2.formatType);
    if ("minuteIncrement" in $$props2)
      $$invalidate(12, minuteIncrement = $$props2.minuteIncrement);
    if ("weekStart" in $$props2)
      $$invalidate(13, weekStart = $$props2.weekStart);
    if ("inputClasses" in $$props2)
      $$invalidate(14, inputClasses = $$props2.inputClasses);
    if ("todayBtnClasses" in $$props2)
      $$invalidate(15, todayBtnClasses = $$props2.todayBtnClasses);
    if ("clearBtnClasses" in $$props2)
      $$invalidate(16, clearBtnClasses = $$props2.clearBtnClasses);
    if ("todayBtn" in $$props2)
      $$invalidate(17, todayBtn = $$props2.todayBtn);
    if ("clearBtn" in $$props2)
      $$invalidate(18, clearBtn = $$props2.clearBtn);
    if ("clearToggle" in $$props2)
      $$invalidate(50, clearToggle = $$props2.clearToggle);
    if ("autoclose" in $$props2)
      $$invalidate(51, autoclose = $$props2.autoclose);
    if ("i18n" in $$props2)
      $$invalidate(19, i18n = $$props2.i18n);
    if ("positionFn" in $$props2)
      $$invalidate(20, positionFn = $$props2.positionFn);
    if ("validatorAction" in $$props2)
      $$invalidate(52, validatorAction = $$props2.validatorAction);
    if ("prevValue" in $$props2)
      $$invalidate(55, prevValue = $$props2.prevValue);
    if ("currentFormat" in $$props2)
      $$invalidate(56, currentFormat = $$props2.currentFormat);
    if ("innerDate" in $$props2)
      $$invalidate(21, innerDate = $$props2.innerDate);
    if ("isFocused" in $$props2)
      $$invalidate(22, isFocused = $$props2.isFocused);
    if ("inputEl" in $$props2)
      $$invalidate(28, inputEl = $$props2.inputEl);
    if ("inputRect" in $$props2)
      $$invalidate(29, inputRect = $$props2.inputRect);
    if ("inputAction" in $$props2)
      $$invalidate(35, inputAction = $$props2.inputAction);
    if ("inputActionParams" in $$props2)
      $$invalidate(36, inputActionParams = $$props2.inputActionParams);
    if ("calendarEl" in $$props2)
      $$invalidate(30, calendarEl = $$props2.calendarEl);
    if ("timeEl" in $$props2)
      $$invalidate(31, timeEl = $$props2.timeEl);
    if ("preventClose" in $$props2)
      preventClose = $$props2.preventClose;
    if ("preventCloseTimer" in $$props2)
      preventCloseTimer = $$props2.preventCloseTimer;
    if ("resolvedMode" in $$props2)
      $$invalidate(23, resolvedMode = $$props2.resolvedMode);
    if ("currentMode" in $$props2)
      $$invalidate(24, currentMode = $$props2.currentMode);
    if ("isMinuteView" in $$props2)
      isMinuteView = $$props2.isMinuteView;
    if ("lastPickerPhase" in $$props2)
      lastPickerPhase = $$props2.lastPickerPhase;
    if ("pickerVisible" in $$props2)
      $$invalidate(25, pickerVisible = $$props2.pickerVisible);
    if ("parsedStartDate" in $$props2)
      $$invalidate(26, parsedStartDate = $$props2.parsedStartDate);
    if ("internalVisibility" in $$props2)
      $$invalidate(32, internalVisibility = $$props2.internalVisibility);
    if ("fadeFn" in $$props2)
      $$invalidate(33, fadeFn = $$props2.fadeFn);
    if ("parsedEndDate" in $$props2)
      $$invalidate(27, parsedEndDate = $$props2.parsedEndDate);
    if ("isTodayDisabled" in $$props2)
      $$invalidate(34, isTodayDisabled = $$props2.isTodayDisabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*format, i18n, formatType*/
    527360 | $$self.$$.dirty[1] & /*startDate*/
    65536) {
      $:
        $$invalidate(26, parsedStartDate = startDate ? parseDate(startDate, format, i18n, formatType) : null);
    }
    if ($$self.$$.dirty[0] & /*format, i18n, formatType*/
    527360 | $$self.$$.dirty[1] & /*endDate*/
    131072) {
      $:
        $$invalidate(27, parsedEndDate = endDate ? new Date(parseDate(endDate, format, i18n, formatType).setSeconds(1)) : null);
    }
    if ($$self.$$.dirty[0] & /*parsedStartDate, parsedEndDate*/
    201326592) {
      $:
        $$invalidate(34, isTodayDisabled = parsedStartDate && parsedStartDate > /* @__PURE__ */ new Date() || parsedEndDate && parsedEndDate < /* @__PURE__ */ new Date());
    }
    if ($$self.$$.dirty[0] & /*pickerOnly*/
    256) {
      $:
        $$invalidate(25, pickerVisible = pickerOnly);
    }
    if ($$self.$$.dirty[0] & /*pickerOnly*/
    256) {
      $:
        $$invalidate(33, fadeFn = pickerOnly ? () => {
        } : fade);
    }
    if ($$self.$$.dirty[0] & /*format, resolvedMode, currentMode*/
    25166848 | $$self.$$.dirty[1] & /*mode*/
    262144) {
      $: {
        $$invalidate(23, resolvedMode = mode === "auto" ? format.match(/g|hh?|ii?/i) && format.match(/y|m|d/i) ? "datetime" : format.match(/g|hh?|ii?/i) ? "time" : "date" : mode);
        if (resolvedMode === "time" && currentMode !== resolvedMode) {
          $$invalidate(24, currentMode = resolvedMode);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inputElement, isFocused*/
    4194305) {
      $: {
        if (inputElement)
          $$invalidate(0, inputElement.readOnly = isFocused, inputElement);
      }
    }
    if ($$self.$$.dirty[0] & /*pickerOnly*/
    256) {
      $:
        $$invalidate(32, internalVisibility = pickerOnly ? true : false);
    }
    if ($$self.$$.dirty[0] & /*value, format, i18n, formatType, innerDate*/
    2624514 | $$self.$$.dirty[1] & /*prevValue, currentFormat, mode*/
    50593792) {
      $: {
        if (value !== prevValue) {
          const parsed = value ? parseDate(value, format, i18n, formatType) : null;
          $$invalidate(21, innerDate = parsed);
          $$invalidate(55, prevValue = value);
        }
        if (currentFormat !== format && innerDate) {
          $$invalidate(1, value = formatDate(innerDate, format, i18n, formatType));
          $$invalidate(55, prevValue = value);
          $$invalidate(56, currentFormat = format);
          if (mode === "auto") {
            $$invalidate(23, resolvedMode = format.match(/g|hh?|ii?/i) && format.match(/y|m|d/i) ? "datetime" : format.match(/g|hh?|ii?/i) ? "time" : "date");
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*pickerVisible*/
    33554432) {
      $:
        if (!pickerVisible)
          isMinuteView = false;
    }
  };
  return [
    inputElement,
    value,
    startView,
    inputId,
    name,
    disabled,
    placeholder,
    required,
    pickerOnly,
    theme,
    format,
    formatType,
    minuteIncrement,
    weekStart,
    inputClasses,
    todayBtnClasses,
    clearBtnClasses,
    todayBtn,
    clearBtn,
    i18n,
    positionFn,
    innerDate,
    isFocused,
    resolvedMode,
    currentMode,
    pickerVisible,
    parsedStartDate,
    parsedEndDate,
    inputEl,
    inputRect,
    calendarEl,
    timeEl,
    internalVisibility,
    fadeFn,
    isTodayDisabled,
    inputAction,
    inputActionParams,
    onDate,
    onToday,
    onClear,
    onKeyDown,
    onModeSwitch,
    onTimeClose,
    onInputFocus,
    onInputBlur,
    onTimeSwitch,
    initialDate,
    startDate,
    endDate,
    mode,
    clearToggle,
    autoclose,
    validatorAction,
    setDateValue,
    getLastPickerPhase,
    prevValue,
    currentFormat,
    mousedown_handler,
    input_handler,
    change_handler,
    input_binding,
    click_handler,
    calendar_binding,
    time_binding
  ];
}
var SveltyPicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        inputId: 3,
        name: 4,
        disabled: 5,
        placeholder: 6,
        required: 7,
        inputElement: 0,
        value: 1,
        initialDate: 46,
        startDate: 47,
        endDate: 48,
        pickerOnly: 8,
        startView: 2,
        theme: 9,
        mode: 49,
        format: 10,
        formatType: 11,
        minuteIncrement: 12,
        weekStart: 13,
        inputClasses: 14,
        todayBtnClasses: 15,
        clearBtnClasses: 16,
        todayBtn: 17,
        clearBtn: 18,
        clearToggle: 50,
        autoclose: 51,
        i18n: 19,
        positionFn: 20,
        validatorAction: 52,
        setDateValue: 53,
        getLastPickerPhase: 54
      },
      add_css3,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SveltyPicker",
      options,
      id: create_fragment3.name
    });
  }
  get inputId() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputElement() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputElement(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialDate() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialDate(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startDate() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startDate(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endDate() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endDate(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pickerOnly() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pickerOnly(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startView() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startView(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatType() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatType(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minuteIncrement() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minuteIncrement(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weekStart() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weekStart(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputClasses() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputClasses(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get todayBtnClasses() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set todayBtnClasses(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearBtnClasses() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearBtnClasses(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get todayBtn() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set todayBtn(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearBtn() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearBtn(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearToggle() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearToggle(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoclose() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoclose(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positionFn() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionFn(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validatorAction() {
    throw new Error("<SveltyPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validatorAction(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setDateValue() {
    return this.$$.ctx[53];
  }
  set setDateValue(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getLastPickerPhase() {
    return this.$$.ctx[54];
  }
  set getLastPickerPhase(value) {
    throw new Error("<SveltyPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SveltyPicker_default = SveltyPicker;

// node_modules/svelty-picker/index.js
var svelty_picker_default = SveltyPicker_default;
export {
  config,
  svelty_picker_default as default,
  formatDate,
  parseDate
};
//# sourceMappingURL=svelty-picker.js.map
